<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java（二）多态</title>
    <url>/2020/11/26/Java%EF%BC%88%E4%BA%8C%EF%BC%89%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现爬取豆瓣电影评论</title>
    <url>/2020/11/10/python%E5%AE%9E%E7%8E%B0%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="python实现爬取豆瓣电影评论"><a href="#python实现爬取豆瓣电影评论" class="headerlink" title="python实现爬取豆瓣电影评论"></a>python实现爬取豆瓣电影评论</h1><h2 id="github"><a href="#github" class="headerlink" title="github"></a><a href="https://github.com/summerainnn/dbSpider">github</a></h2><h2 id="使用的库"><a href="#使用的库" class="headerlink" title="使用的库"></a>使用的库</h2><p>以前在写爬虫时使用的都是reques，这次发现了更好用的request_html，不需要再用bs4来解析网页了</p>
<blockquote>
<p>request_html</p>
</blockquote>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>首先建立一个会话（session），即让Python作为一个客户端，和远端服务器交谈</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">session = HTMLSession()</span><br></pre></td></tr></table></figure>

<p>然后就可以用session来进行get的操作，这里的URL可以自己在浏览器中寻找，找到你需要的数据的具体的get的网址，该网址并不一定是网页网址</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><a href="https://pypi.org/project/requests-html/">官方文档</a></h3><h3 id="如何用Python爬数据？（一）网页抓取"><a href="#如何用Python爬数据？（一）网页抓取" class="headerlink" title="如何用Python爬数据？（一）网页抓取"></a><a href="https://www.jianshu.com/p/ba02079ecd2f">如何用Python爬数据？（一）网页抓取</a></h3><h3 id="requests-html"><a href="#requests-html" class="headerlink" title="requests-html"></a><a href="https://www.jianshu.com/p/380974ba9540">requests-html</a></h3>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>应用</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode：26.删除排序数组中的重复项</title>
    <url>/2020/11/08/leetcode%EF%BC%9A26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26.删除排序数组中的重复项"></a>26.删除排序数组中的重复项</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">LeetCode</a></h3><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><ul>
<li>快慢两个指针，前一个用来计数，后一个用来遍历数组，在找到不同数字后进行交换</li>
<li>时间复杂度o（n），空间复杂度o（1）</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j];<span class="comment">//存在此时i==j的情况，可优化</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>重复</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>使用阿里云和hexo搭建个人博客</title>
    <url>/2020/12/02/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="使用阿里云和hexo搭建个人博客"><a href="#使用阿里云和hexo搭建个人博客" class="headerlink" title="使用阿里云和hexo搭建个人博客"></a>使用阿里云和hexo搭建个人博客</h1><p>本次主要参考的是<a href="https://blog.csdn.net/qq_37391214/article/details/106161526">阿里云服务器和 hexo 博客实战</a></p>
<p>现对其中遇到的问题进行总结</p>
<h2 id="1-nginx编译问题"><a href="#1-nginx编译问题" class="headerlink" title="1.nginx编译问题"></a>1.nginx编译问题</h2><p>原文提到的nginx版本有一点问题，无法通过编译，我选择了nginx-1.19.5这样一个版本</p>
<h2 id="2-双推送"><a href="#2-双推送" class="headerlink" title="2.双推送"></a>2.双推送</h2><p>因为域名是在阿里云购买的，必须绑定阿里云的服务器，此次迁移博客也是因为这个原因，但是还是希望推送到GitHub上，所以可以对_config.yml文件进行修改，使其可以推送到两个服务器上</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9u32tm91j319e0aqwgb.jpg" alt="image-20201202213036808"></p>
<h2 id="3-nginx配置问题"><a href="#3-nginx配置问题" class="headerlink" title="3.nginx配置问题"></a>3.nginx配置问题</h2><p>nginx修改配置后需要再次重启nginx，才能使得配置生效</p>
]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>应用</tag>
        <tag>网站开发</tag>
        <tag>问题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Java（一）接口</title>
    <url>/2020/11/26/Java%EF%BC%88%E4%B8%80%EF%BC%89%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="Java（一）接口"><a href="#Java（一）接口" class="headerlink" title="Java（一）接口"></a>Java（一）接口</h1><h2 id="1-定义格式"><a href="#1-定义格式" class="headerlink" title="1.定义格式"></a>1.定义格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;</span><br><span class="line">	<span class="comment">// 接口内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-使用步骤"><a href="#2-使用步骤" class="headerlink" title="2.使用步骤"></a>2.使用步骤</h2><ol>
<li><p>接口不能直接使用，必须有一个“实现类”来“实现”该接口</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 实现类名称 <span class="keyword">implements</span> 接口名称</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口的实现类必须覆盖重写（实现）接口中的所有抽象方法</p>
<p> 实现：去掉abstract关键字，加上方法体大括号</p>
</li>
<li><p>创建实现类的对象，进行使用</p>
</li>
</ol>
<h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h2><p>如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类</p>
<h2 id="4-具体例子"><a href="#4-具体例子" class="headerlink" title="4.具体例子"></a>4.具体例子</h2><ol>
<li><p>MyInterfaceAbstract</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceAbstract</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接口中也可以定义“成员变量”，但是必须用public static final三个关键字进行修饰</span></span><br><span class="line">    <span class="comment">// 从效果上看，这就是接口的【常量】</span></span><br><span class="line">    <span class="comment">// 可以省略public static final三个关键字不写，但效果是等同的</span></span><br><span class="line">    <span class="comment">// 该常量必须手动赋值，且不可改变</span></span><br><span class="line">    <span class="comment">// 推荐命名规则，全大写，使用下划线分隔单词</span></span><br><span class="line">    <span class="comment">// 访问时直接用接口名称调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_OF = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// public abstract可以省略，默认为抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新添加一个默认方法，可用于接口升级，使之前实现的类不需要重写该方法，也能继续使用</span></span><br><span class="line">    <span class="comment">// 该默认方法可以在实现类中直接调用，也可以进行覆盖重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接口中也可以定义静态方法，通过接口名称直接调用静态方法，即可使用</span></span><br><span class="line">    <span class="comment">// 注意事项：不能通过接口实现类来调用接口中的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接口中可以定义私有方法，使得该方法不会被实现类访问,但可以被接口中的默认方法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodCommon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接口中可以定义静态私有方法，使得该方法不会被实现类访问,但可以被接口中的静态方法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStaticCommon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MyInterfaceAbstractImpl</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceAbstractImpl</span> <span class="keyword">implements</span> <span class="title">MyInterfaceAbstract</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="5-接口的实现类"><a href="#5-接口的实现类" class="headerlink" title="5.接口的实现类"></a>5.接口的实现类</h2><p>一个类可以实现多个接口，但所有接口中的抽象方法都要重写</p>
<p>如果实现多个接口中存在重复的抽象方法，只需要覆盖重写一次即可</p>
<p>如果实现多个接口中存在重复的默认方法，需要覆盖重写</p>
<p>如果类的父类方法和接口中的默认方法产生冲突，优先使用父类方法</p>
<p>接口是可以多继承接口的，父接口的默认方法冲突需要重写，抽象方法冲突无影响</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode：21.合并两个有序链表</title>
    <url>/2020/11/08/Leetcode%EF%BC%9A21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">LeetCode</a></h3><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><ul>
<li>时间复杂度为o（m+n）</li>
<li>空间复杂度o（m+n）这是递归调用的深度，即最多调用m+n次</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><ul>
<li>时间复杂度o（m+n）</li>
<li>空间复杂度o（1），仅需要常数个node作为临时储存</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode answer = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode temp = answer;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                temp.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = l1==<span class="keyword">null</span>? l2:l1;</span><br><span class="line">        <span class="keyword">return</span> answer.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>合并</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能</title>
    <url>/2020/11/15/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
    <content><![CDATA[<h1 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h1><h2 id="什么是人工智能？"><a href="#什么是人工智能？" class="headerlink" title="什么是人工智能？"></a>什么是人工智能？</h2><ul>
<li>类人类思维方法：认知模型方法</li>
<li>类人行为方法：图灵测试</li>
<li>理性思维方法：思维法则</li>
<li>理性行为方法：理性智能体</li>
</ul>
<p>一般解释：用人工的方法在机器（计算机）上实现的智能</p>
<h2 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h2><h3 id="产生式表达法"><a href="#产生式表达法" class="headerlink" title="产生式表达法"></a>产生式表达法</h3><h4 id="事实的表示"><a href="#事实的表示" class="headerlink" title="事实的表示"></a>事实的表示</h4><h5 id="确定性知识表示"><a href="#确定性知识表示" class="headerlink" title="确定性知识表示"></a>确定性知识表示</h5><ul>
<li>（对象，属性，值） 例如：（雪，颜色，白）</li>
<li>（关系，对象1，对象2） 例如（热爱，汪峰，祖国）</li>
</ul>
<h5 id="非确定性知识："><a href="#非确定性知识：" class="headerlink" title="非确定性知识："></a>非确定性知识：</h5><ul>
<li>（对象，属性，值，可信度因子）</li>
</ul>
<h4 id="规则的表示"><a href="#规则的表示" class="headerlink" title="规则的表示"></a>规则的表示</h4><p>P -&gt; Q     IF P THEN Q</p>
<h3 id="语义网络表示法"><a href="#语义网络表示法" class="headerlink" title="语义网络表示法"></a>语义网络表示法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[节点1]--&gt;|语义关系|B[节点2] </span><br></pre></td></tr></table></figure>

<h4 id="基本语义关系"><a href="#基本语义关系" class="headerlink" title="基本语义关系"></a>基本语义关系</h4><ul>
<li>实例关系：ISA（是一个）</li>
<li>分类关系：AKO（是一种）</li>
<li>成员关系：A-Member-of（是一员）</li>
<li>聚类关系：Part-of（是一部分）</li>
<li>属性关系：<ul>
<li>Have（有） </li>
<li>Can（能，会）</li>
</ul>
</li>
<li>时间关系：<ul>
<li>Before（在前）</li>
<li>After（在后）</li>
</ul>
</li>
<li>位置关系：Locate-on（在···上面）</li>
<li>相近关系：Similar-to（相似）Near-to（接近）</li>
</ul>
<h3 id="框架表示法"><a href="#框架表示法" class="headerlink" title="框架表示法"></a>框架表示法</h3><h4 id="框架的结构："><a href="#框架的结构：" class="headerlink" title="框架的结构："></a>框架的结构：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Frame&lt;框架名&gt;</span><br><span class="line">槽名A：侧面名A1		值A11	值A12</span><br><span class="line">			侧面名A2		值A21  值A22</span><br><span class="line">槽名B：侧面名B1		值B11	值B12</span><br><span class="line">			侧面名A2		值B21  值B22</span><br></pre></td></tr></table></figure>

<h2 id="推理的分类"><a href="#推理的分类" class="headerlink" title="推理的分类"></a>推理的分类</h2><h4 id="演绎推理"><a href="#演绎推理" class="headerlink" title="演绎推理"></a>演绎推理</h4><p>常用形式：三段论</p>
<p>不能增值新知识</p>
<h4 id="归纳推理"><a href="#归纳推理" class="headerlink" title="归纳推理"></a>归纳推理</h4><p>从个别到一般的推理</p>
<p>可以增值新知识</p>
]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer：11.旋转数组的最小数字</title>
    <url>/2020/11/23/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a>剑指 Offer 11. 旋转数组的最小数字</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">LeetCode</a></h3><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><ul>
<li>一个有一定顺序的数组一般就考虑二分法来进行查找，使得时间复杂度降低到对数级别</li>
</ul>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[<span class="number">0</span>]&lt;numbers[numbers.length-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start != end)&#123;</span><br><span class="line">            mid = (start + end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start;numbers[mid]==numbers[start];i++)&#123;</span><br><span class="line">                mid = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(mid == numbers.length)&#123;</span><br><span class="line">                    mid = mid-<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid]&gt;numbers[start])&#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(start + <span class="number">1</span> == end)&#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[end];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="官方简洁版代码"><a href="#官方简洁版代码" class="headerlink" title="官方简洁版代码"></a>官方简洁版代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[pivot] &lt; numbers[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[pivot] &gt; numbers[high]) &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 13. 机器人的运动范围</title>
    <url>/2020/11/25/%E5%89%91%E6%8C%87%20Offer%2013.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<h1 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a>剑指 Offer 13. 机器人的运动范围</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">LeetCode</a></h3><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul>
<li>简单的dfs题目，用递归来实现即可</li>
<li>对于已到达的点需要进行标记，以便后续检查该点是否已到达</li>
</ul>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>对于简单的运算不要再写函数，否则反而因为调用函数而浪费了时间和空间</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] map = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,map,<span class="number">1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">boolean</span>[][] map, <span class="keyword">int</span> num,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==map.length||y==map[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((x/<span class="number">10</span>+x%<span class="number">10</span>+y/<span class="number">10</span>+y%<span class="number">10</span>)&lt;=k&amp;&amp; !map[x][y])&#123;</span><br><span class="line">                map[x][y] = <span class="keyword">true</span>;</span><br><span class="line">                num = dfs(x+<span class="number">1</span>,y,map,num,k) + dfs(x,y+<span class="number">1</span>,map,num,k) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>dfs</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 14- II. 剪绳子 II</title>
    <url>/2020/11/30/%E5%89%91%E6%8C%87%20Offer%2014-%20II.%20%E5%89%AA%E7%BB%B3%E5%AD%90%20II/</url>
    <content><![CDATA[<h1 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a>剑指 Offer 14- II. 剪绳子 II</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof">LeetCode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>首先找出规律，分成3相乘时，积最大，但是当剩余的长度为4时，分成2和2最大</li>
<li>需要定义long，使用int会有溢出的风险</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">4</span>)&#123;</span><br><span class="line">            sum = sum * <span class="number">3</span>;</span><br><span class="line">            sum = sum %<span class="number">1000000007</span>;</span><br><span class="line">            n = n - <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if(n==4)&#123;</span></span><br><span class="line">        <span class="comment">//     return sum*4%1000000007;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(n==3)&#123;</span></span><br><span class="line">        <span class="comment">//     return sum*3%1000000007;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(n == 2)&#123;</span></span><br><span class="line">        <span class="comment">//     return sum*2%1000000007;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (sum*n%<span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 15. 二进制中1的个数</title>
    <url>/2020/11/30/%E5%89%91%E6%8C%87%20Offer%2015.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a>剑指 Offer 15. 二进制中1的个数</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<p> 示例 1：</p>
<p>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<br>示例 2：</p>
<p>输入：00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。<br>示例 3：</p>
<p>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p>
<p>提示：</p>
<p>输入必须是长度为 32 的 二进制串 。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof">LeetCode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>使用移位的方法，来对每一位进行判断，是否为1</li>
<li>时间复杂度为O（$log_2N$）(此处的N并不是二进制的位数)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            res += n &amp; <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用n&amp;(n-1)的方法，对n进行减一的操作，再与原来的数进行与操作，可以使得该数的低位第一个1变成0</li>
<li>时间复杂度相比上一个方法有所降低</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 22. 链表中倒数第k个节点</title>
    <url>/2020/12/01/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p>示例：</p>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p>
<p>返回链表 4-&gt;5.</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">LeetCode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>链表中计数巧妙的使用双指针，让一个先行，另一个后续尾行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode start = head;</span><br><span class="line">        ListNode end = head;</span><br><span class="line">        <span class="keyword">for</span>(;k&gt;<span class="number">0</span>;k--)&#123;</span><br><span class="line">            end = end.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(end!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            start = start.next;</span><br><span class="line">            end = end.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 18. 删除链表的节点</title>
    <url>/2020/12/01/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。 </p>
<p>注意：此题对比原题有改动</p>
<p>示例 1:</p>
<p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p>
<p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof">LeetCode</a></h3><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul>
<li>对链表有基本的了解即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.val == val) &#123;</span><br><span class="line">            <span class="comment">//如果要删除的是头指针，直接令 head 指向下一个结点</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode n = head;</span><br><span class="line">        <span class="keyword">while</span>(n.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n.next.val == val)&#123;</span><br><span class="line">                n.next = n.next.next;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 24. 反转链表</title>
    <url>/2020/12/12/%E5%89%91%E6%8C%87%20Offer%2024.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>剑指 Offer：09.用两个栈实现队列</title>
    <url>/2020/11/14/%E5%89%91%E6%8C%87%20Offer%EF%BC%9A09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="剑指-Offer：09-用两个栈实现队列"><a href="#剑指-Offer：09-用两个栈实现队列" class="headerlink" title="剑指 Offer：09.用两个栈实现队列"></a>剑指 Offer：09.用两个栈实现队列</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>用两个栈实现一个队列。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">LeetCode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>队列是先进后出，而栈是先进先出</li>
<li>用两个栈，一个用来入栈，一个用来出栈</li>
<li>对于一系列存在一个栈内的数据出栈再入栈，那么它们在栈内储存的顺序就会反过来，即可实现队列</li>
</ul>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1;</span><br><span class="line">    Stack&lt;Integer&gt; s2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        s2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s2.empty()&amp;&amp;s1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer：04.二维数组中的查找</title>
    <url>/2020/11/09/%E5%89%91%E6%8C%87%20Offer%EF%BC%9A04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="剑指-Offer：04-二维数组中的查找"><a href="#剑指-Offer：04-二维数组中的查找" class="headerlink" title="剑指 Offer：04.二维数组中的查找"></a>剑指 Offer：04.二维数组中的查找</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">LeetCode</a></h3><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>根据该数组的特点，可从数组的右上角或者左下角开始，进行求解</li>
<li>专注于当前点，而不是下一个点，因为根据当前点即可判断出下一个点的位置，这也是初始点选择的好处所在</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = columns-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row&lt;rows&amp;&amp;column&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = matrix[row][column];</span><br><span class="line">            <span class="keyword">if</span>(num==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;target)&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                column--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
        <tag>线性查找</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer：07.重建二叉树</title>
    <url>/2020/11/14/%E5%89%91%E6%8C%87%20Offer%EF%BC%9A07.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="剑指-Offer：07-重建二叉树"><a href="#剑指-Offer：07-重建二叉树" class="headerlink" title="剑指 Offer：07.重建二叉树"></a>剑指 Offer：07.重建二叉树</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">&gt;中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>返回如下的二叉树：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">LeetCode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>首先理解什么是前序遍历和中序遍历：<ul>
<li>前序遍历：按照 根-&gt;左节点-&gt;右节点的顺序来遍历显示</li>
<li>中序遍历：按照 左节点-&gt;根-&gt;右节点的顺序来遍历显示</li>
</ul>
</li>
<li>前序遍历的首位一定是根结点，接着是这个根结点的左子树，然后是右子树</li>
<li>中序遍历的左部分为左子树，然后是根结点，接着是这个根结点的右子树</li>
<li>递归解决：<ul>
<li>用前序遍历找到根结点</li>
<li>在中序遍历中找到根结点，那么从根结点划分出两个子树，同时分出前序遍历的左右子树</li>
<li>重复该步骤，直到子树只有一个根结点</li>
</ul>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode father = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(inorder.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> father;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == preorder[<span class="number">0</span>])&#123;</span><br><span class="line"></span><br><span class="line">                father.left =  buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),</span><br><span class="line">                                         Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                father.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,</span><br><span class="line">                                                            preorder.length),</span><br><span class="line">                                         Arrays.copyOfRange(inorder,</span><br><span class="line">                                                            i+<span class="number">1</span>,inorder.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>可以新建一个类似的函数，改变传入的参数，直接使用原数组的空间，而不是子树遍历的拷贝</p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer：10- I. 斐波那契数列</title>
    <url>/2020/11/18/%E5%89%91%E6%8C%87%20Offer%EF%BC%9A10-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="剑指-Offer：10-I-斐波那契数列"><a href="#剑指-Offer：10-I-斐波那契数列" class="headerlink" title="剑指 Offer：10- I. 斐波那契数列"></a>剑指 Offer：10- I. 斐波那契数列</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项。斐波那契数列的定义如下：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof">LeetCode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>斐波拉契数列是递归的典型应用，但是在使用递归时实际上做了很多无用功，对很多值进行了重复计数</li>
<li>利用动态规划的思想，将计算过的数值进行储存再利用即可</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i!=n)&#123;</span><br><span class="line">            sum = (s1 + s2) % <span class="number">1000000007</span>;</span><br><span class="line">            s1 = s2;</span><br><span class="line">            s2 = sum;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer：10- II. 青蛙跳台阶问题</title>
    <url>/2020/11/18/%E5%89%91%E6%8C%87%20Offer%EF%BC%9A10-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="剑指-Offer：10-II-青蛙跳台阶问题"><a href="#剑指-Offer：10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer：10- II. 青蛙跳台阶问题"></a>剑指 Offer：10- II. 青蛙跳台阶问题</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">LeetCode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>简单分析可知，此题为斐波拉契数列的一种形式应用，与上一题类似</li>
<li>需要注意的是改变了斐波拉契数列的初始值</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numWays(int n) &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n&#x3D;&#x3D;2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int i &#x3D;2;</span><br><span class="line">        int s1 &#x3D; 1;</span><br><span class="line">        int s2 &#x3D; 2;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        while(i!&#x3D;n)&#123;</span><br><span class="line">            sum &#x3D; (s1 + s2) % 1000000007;</span><br><span class="line">            s1 &#x3D; s2;</span><br><span class="line">            s2 &#x3D; sum;</span><br><span class="line">            i &#x3D; i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer：03.数组中的重复元素</title>
    <url>/2020/11/08/%E5%89%91%E6%8C%87%20Offer%EF%BC%9A03.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="剑指-Offer：03-数组中的重复元素"><a href="#剑指-Offer：03-数组中的重复元素" class="headerlink" title="剑指 Offer：03.数组中的重复元素"></a>剑指 Offer：03.数组中的重复元素</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<h3 id="LeetCoed"><a href="#LeetCoed" class="headerlink" title="LeetCoed"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">LeetCoed</a></h3><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="对原数组进行改变"><a href="#对原数组进行改变" class="headerlink" title="对原数组进行改变"></a>对原数组进行改变</h3><ul>
<li>实现复杂度为o（n），空间复杂度为o（1）</li>
</ul>
<ul>
<li>此处可对所有的重复数字进行查找</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                <span class="keyword">if</span>(nums[temp]==nums[i])&#123;</span><br><span class="line">                    answer[index] = nums[i];</span><br><span class="line">                    index++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[i] = nums[temp];</span><br><span class="line">                nums[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        answer[<span class="number">0</span>] = index-<span class="number">1</span>;<span class="comment">//用answer的第一个空间存储重复元素个数，可以实现多元素查找</span></span><br><span class="line">        <span class="keyword">return</span> answer[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="不改变原数组"><a href="#不改变原数组" class="headerlink" title="不改变原数组"></a>不改变原数组</h3><ul>
<li><p>用辅助数组进行，牺牲空间复杂度为o（n），时间复杂度仍为o（n）</p>
</li>
<li><p>用二分法可以将空间复杂度变为o（1），但时间复杂度为o（nlogn）<strong>（仅可查找一个重复元素，同时该方法要求数组元素的数量比所有数字的数量更大）</strong></p>
</li>
<li><p>使用HashSet同样可以实现时间复杂度为o（n）的解法，同时不用改变原数组</p>
</li>
</ul>
<p><em>HashSet是通过HashMap实现的一个不包含重复元素的集合，且没有key-value的对应关系</em></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; dic = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dic.add(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>重复</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer：12.矩阵中的路径</title>
    <url>/2020/11/24/%E5%89%91%E6%8C%87%20Offer%EF%BC%9A12.%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="剑指-Offer：12-矩阵中的路径"><a href="#剑指-Offer：12-矩阵中的路径" class="headerlink" title="剑指 Offer：12.矩阵中的路径"></a>剑指 Offer：12.矩阵中的路径</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">LeetCode</a></h3><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul>
<li>这是一道比较典型的需要用到dfs的题目</li>
<li>需要对已经经过的点进行标记，完成后需要再恢复</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>专注于当前的点，而不是顾虑太多其它点，对每个点就行同样的处理，而不是特殊化</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, i, j,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word,<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;board.length-<span class="number">1</span>||y&gt;board[<span class="number">0</span>].length-<span class="number">1</span>||x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp = board[x][y];</span><br><span class="line">        <span class="keyword">if</span>(board[x][y] == word.charAt(k))&#123;</span><br><span class="line">            <span class="keyword">if</span>(k == word.length()-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">            board[x][y] =<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfs(board,word,x+<span class="number">1</span>,y,k)||dfs(board,word,x-<span class="number">1</span>,y,k)</span><br><span class="line">                    ||dfs(board,word,x,y+<span class="number">1</span>,k)||dfs(board,word,x,y-<span class="number">1</span>,k))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>dfs</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（三）系统调用</title>
    <url>/2020/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="一、系统调用的意义"><a href="#一、系统调用的意义" class="headerlink" title="一、系统调用的意义"></a>一、系统调用的意义</h2><p>操作系统提供给应用程序使用的接口，来获得操作系统的服务</p>
<p>系统调用使得系统中的各种资源由操作系统统一掌控</p>
<h2 id="二、系统调用和库函数的区别"><a href="#二、系统调用和库函数的区别" class="headerlink" title="二、系统调用和库函数的区别"></a>二、系统调用和库函数的区别</h2><p>库函数封装了系统调用</p>
<h2 id="三、系统调用的过程"><a href="#三、系统调用的过程" class="headerlink" title="三、系统调用的过程"></a>三、系统调用的过程</h2><ol>
<li>传递系统调用参数</li>
<li>执行陷入指令（只能在用户态执行的指令，不能在和心态执行）</li>
<li>执行系统调用相应服务程序</li>
<li>返回用户程序</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（二）中断和异常</title>
    <url>/2020/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><h2 id="一、中断的意义"><a href="#一、中断的意义" class="headerlink" title="一、中断的意义"></a>一、中断的意义</h2><p>实现多道程序并发执行</p>
<p>本质：发生中断，意味着需要操作系统介入，开展管理工作（中断是唯一途径使得用户态-&gt;核心态）</p>
<h2 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h2><ul>
<li>中断发生时，CPU立即进入核心态</li>
<li>中断发生后，当前进程暂停运行，并由操作系统内核对中断进行处理</li>
<li>对不同的中断信号，会进行不同的处理</li>
</ul>
<h2 id="三、分类"><a href="#三、分类" class="headerlink" title="三、分类"></a>三、分类</h2><ul>
<li>内中断（异常）：信号来自CPU内部，与当前执行的指令有关<ul>
<li>自愿中断（指令中断）</li>
<li>强迫中断<ul>
<li>硬件故障</li>
<li>软件中断</li>
</ul>
</li>
</ul>
</li>
<li>外中断（中继）：信号来自CPU外部，与当前执行的指令无关<ul>
<li>外设请求</li>
<li>人工干预</li>
</ul>
</li>
</ul>
<h2 id="四、外中断的处理过程"><a href="#四、外中断的处理过程" class="headerlink" title="四、外中断的处理过程"></a>四、外中断的处理过程</h2><ol>
<li>执行完每个指令后都要检查是否有外部中断信号</li>
<li>如果检测到外部中断信号，则需要保护被中断进程的CPU环境</li>
<li>根据中断信号转入相应的中断处理程序</li>
<li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（一）概念和定义</title>
    <url>/2020/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<h1 id="操作系统的概念和定义"><a href="#操作系统的概念和定义" class="headerlink" title="操作系统的概念和定义"></a>操作系统的概念和定义</h1><h2 id="一、操作系统的功能和目标："><a href="#一、操作系统的功能和目标：" class="headerlink" title="一、操作系统的功能和目标："></a>一、操作系统的功能和目标：</h2><h3 id="1-作为系统资源的管理者"><a href="#1-作为系统资源的管理者" class="headerlink" title="1.作为系统资源的管理者"></a>1.作为系统资源的管理者</h3><ul>
<li>提供的功能<ul>
<li>处理机管理</li>
<li>储存器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
</li>
<li>目标： 安全、高效</li>
</ul>
<h3 id="2-作为用户和计算机硬件之间的接口"><a href="#2-作为用户和计算机硬件之间的接口" class="headerlink" title="2.作为用户和计算机硬件之间的接口"></a>2.作为用户和计算机硬件之间的接口</h3><ul>
<li>提供的功能<ul>
<li>命令接口<ul>
<li>联机命令接口：交互式命令接口（实时反馈）</li>
<li>脱机命令接口：批处理命令接口（系列指令执行）</li>
</ul>
</li>
<li>程序接口：系统调用（广义指令）</li>
<li>CUI（图形用户界面）</li>
</ul>
</li>
<li>目标：方便用户使用</li>
</ul>
<h3 id="3-实现对硬件机器的拓展"><a href="#3-实现对硬件机器的拓展" class="headerlink" title="3.实现对硬件机器的拓展"></a>3.实现对硬件机器的拓展</h3><h2 id="二、操作系统的特征"><a href="#二、操作系统的特征" class="headerlink" title="二、操作系统的特征"></a>二、操作系统的特征</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1.并发"></a>1.并发</h3><p>微观上交替，宏观上同时</p>
<h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2.共享"></a>2.共享</h3><ul>
<li>互斥共享：一个时间段只允许一个进程访问该资源</li>
<li>同时共享：允许一个时间段内多个进程“同时”对它们访问（宏观上同时）</li>
</ul>
<h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3.虚拟"></a>3.虚拟</h3><p>把一个物理上的实体变为若干个逻辑上的对应物物理实体是实际存在的，而逻辑对应物是用户感受到的</p>
<ul>
<li>空分复用技术（虚拟储存技术）</li>
<li>时分复用技术（虚拟处理器）</li>
</ul>
<h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4.异步"></a>4.异步</h3><p>允许多个程序并发执行，由于资源有限，进程执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学</title>
    <url>/2020/12/13/%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>密码术：密码编码学+密码分析学</p>
<p>扩散：<strong>让明文中的每一位影响密文中的许多位，或者说让密文中的每一位受明文中的许多位的影响</strong>（明文<strong>统计特性散布</strong>到密文中）</p>
<p>混淆：<strong>将密文与密钥之间的统计关系变得尽可能复杂</strong></p>
<p>扩散和混淆的目的是为了抵抗对手对密码体制的统计分析（<strong>乘积和迭代有助于实现扩散和混淆</strong>）</p>
<p>对称加密：加密和解密由同一个密钥来控制，就是对称算法（单匙算法）</p>
<pre><code>- **加密** ：$E_K(M)=C$
- **解密** ：$D_K(C)=M$</code></pre>
<p>非对称加密：用作加密的密钥不同于用作解密的密钥，而且解密密钥不能根据加密密钥计算出来，就是非对称算法（公钥加密）</p>
<ul>
<li><strong>加密</strong> ：$E_{K1}(M)=C$</li>
<li><strong>解密</strong> ：$D_{K2}(C)=M$</li>
</ul>
<p>密码系统的攻击类型：</p>
<p><strong>（1）唯密文攻击</strong>：密码分析者仅知道一些密文。</p>
<p><strong>（2）已知明文攻击</strong>：密码分析者知道一些明文和相应的密文。</p>
<p><strong>（3）选择明文攻击</strong>：密码分析者可以选择一些明文，并得到相应的密文。</p>
<p><strong>（4）选择密文攻击</strong>：密码分析者可以选择一些密文，并得到相应的明文。</p>
<h3 id="分组密码工作模式"><a href="#分组密码工作模式" class="headerlink" title="分组密码工作模式:"></a>分组密码工作模式:</h3><p>电子密码本(Electronic Code Book, ECB)模式</p>
<p>​    Ø最简单的工作模式</p>
<p>​    Ø加密：一次对一个64比特长的明文分组加密，每次加密密钥相同</p>
<p>​    Ø适用于短消息加密传输</p>
<p>密码分组链接(Cipher Block Chaining, CBC)模式</p>
<p>​    Ø加密：一次对一个明文分组加密，每次加密使用同一密钥，加密算法的输入是当前明文分组和前一次密文分组的异或</p>
<p>密码反馈（Cipher Feedback，CFB）模式</p>
<p>​    <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmnqbyx7pj30h409l3za.jpg" alt="img"></p>
<p>输出反馈（Output Feedback, OFB）模式</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmnrckjgrj30hm0gowgd.jpg" alt="OFB加密和解密"></p>
<p>计数器模式(CTR, Counter Mode)</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmnrkxs5tj30fm0ch3zk.jpg" alt="img"></p>
<h2 id="数学基础知识"><a href="#数学基础知识" class="headerlink" title="数学基础知识"></a>数学基础知识</h2><p>扩展欧几里得算法：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmhub891mj30sw0jkwj1.jpg" alt="image-20201213201918360"></p>
<p>中国剩余定理：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmikbw9m8j31hc0kswnz.jpg" alt="image-20201213204421185"></p>
<p>费马小定理：</p>
<p>p为质数，a为任意自然数</p>
<p>$a^{p-1}\equiv1\ (mod\ p)$</p>
<p>密码算法四种性质：机密性、完整性、消息认证、不可否认</p>
<h2 id="密码算法"><a href="#密码算法" class="headerlink" title="密码算法"></a>密码算法</h2>]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（六）进程</title>
    <url>/2020/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%85%AD%EF%BC%89%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机网络（一）基本概念</title>
    <url>/2020/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</p>
<p><strong><em>计算机网络是互联的、自治的计算机集合</em></strong></p>
<h2 id="二、功能"><a href="#二、功能" class="headerlink" title="二、功能"></a>二、功能</h2><ol>
<li>数据通信（连通性）</li>
<li>资源共享（硬件、软件和数据）</li>
<li>分布式处理（多台计算机各自承担同一工作的不同部分）</li>
<li>提高可靠性</li>
<li>负载均衡</li>
</ol>
<h2 id="三、组成"><a href="#三、组成" class="headerlink" title="三、组成"></a>三、组成</h2><ol>
<li>组成部分：硬件、软件、协议</li>
<li>工作方式：<ul>
<li>边缘部分：用户直接使用（C/S、P2P）</li>
<li>核心部分：为边缘部分服务</li>
</ul>
</li>
<li>功能组成：<ul>
<li>通信子网：实现数据通信</li>
<li>资源子网：实现资源共享/数据处理</li>
</ul>
</li>
</ol>
<h2 id="四、分类"><a href="#四、分类" class="headerlink" title="四、分类"></a>四、分类</h2><ol>
<li><p>按分布范围</p>
<ul>
<li>广域网WAN（交换技术）</li>
<li>城域网MAN</li>
<li>局域网LAN（广播技术）</li>
<li>个人区域网（PAN）</li>
</ul>
</li>
<li><p>按使用者分：公用网，专用网</p>
</li>
<li><p>按交换技术分：电路交换，报文交换，分组交换</p>
</li>
<li><p>按拓扑结构分：</p>
<p> <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl1oy3x8dtj30ie0aqjrq.jpg" alt="img"></p>
</li>
<li><p>按传输技术分：</p>
<ul>
<li>广播式网络：共享公共通信信道</li>
<li>点对点网络：使用分组储存转发和路由选择机制</li>
</ul>
</li>
</ol>
<h2 id="五、标准化工作"><a href="#五、标准化工作" class="headerlink" title="五、标准化工作"></a>五、标准化工作</h2><h3 id="标准的分类："><a href="#标准的分类：" class="headerlink" title="标准的分类："></a>标准的分类：</h3><ol>
<li>法定标准：由权威制定（OSI）</li>
<li>事实标准：由某些产品的主流技术（TCP/IP）</li>
</ol>
<h3 id="RFC（Request-For-Comments）"><a href="#RFC（Request-For-Comments）" class="headerlink" title="RFC（Request For Comments）"></a>RFC（Request For Comments）</h3><p>RFC是因特网的标准形式</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理</title>
    <url>/2020/12/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>转载整合自<a href="https://www.bilibili.com/video/BV1ft4y1X7p6?p=3">编译原理—混子速成期末保过</a></p>
<h2 id="一、习题"><a href="#一、习题" class="headerlink" title="一、习题"></a>一、习题</h2><h3 id="1-集合"><a href="#1-集合" class="headerlink" title="1.集合"></a>1.集合</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glv8ro5i34j30ti0ckgng.jpg" alt="image-20201221095523996"></p>
<h3 id="2-文法"><a href="#2-文法" class="headerlink" title="2.文法"></a>2.文法</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glv8s4hlzdj31420aigmy.jpg" alt="image-20201219212804466"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glthninja4j318s0rye7u.jpg" alt="image-20201219213146516"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glthqe21i2j312g05en56.jpg" alt="image-20201219213431745"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gltif5j3k7j317g0b0dti.jpg" alt="image-20201219215819514"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glv8srstrwj30n808udh2.jpg" alt="image-20201219220301895"></p>
<h3 id="3-词法分析"><a href="#3-词法分析" class="headerlink" title="3.词法分析"></a>3.词法分析</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glti6ut0j1j30xq0acthn.jpg" alt="image-20201219215021767"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gltjb4h3jpj31by0i8qhu.jpg" alt="image-20201219222903897"></p>
<h3 id="4-语法分析"><a href="#4-语法分析" class="headerlink" title="4.语法分析 "></a>4.语法分析 <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glv8ssam0rj3108074q3v.jpg" alt="image-20201220100828634"></h3><h2 id="二、PPT重难点合集"><a href="#二、PPT重难点合集" class="headerlink" title="二、PPT重难点合集"></a>二、PPT重难点合集</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><ul>
<li>重点：<ul>
<li>编译系统的结构：<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu3x51inmj312y0u0q9k.jpg" alt="image-20201220102212223"></li>
</ul>
</li>
<li>难点：<ul>
<li>编译程序的生成<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glv8stqmlnj30ng09gt9e.jpg" alt="image-20201220103759973"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glv8st8z0cj30y20m6q66.jpg" alt="image-20201220103835776"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu4kg0oo3j31ag0cytaa.jpg" alt="image-20201220103903408"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu4kf9kzyj31ak0dq3zy.jpg" alt="image-20201220103932642"></li>
</ul>
</li>
</ul>
<h3 id="2-高级语言及其文法"><a href="#2-高级语言及其文法" class="headerlink" title="2.高级语言及其文法"></a>2.高级语言及其文法</h3><ul>
<li><p>重点：</p>
<ul>
<li><p>文法的定义与分类</p>
<ul>
<li><p>定义一个包含元素的集合为一个字母表∑</p>
</li>
<li><p>对字母表可进行乘和加。</p>
</li>
<li><p>$$<br>  ∑^+ = ∑^1+∑^2+∑^3+…\<br>  ∑^* = ∑^0+∑^1+∑^2+…\<br>  对任意的∑^0 = {ε}<br>  $$</p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu4xyanwpj31420aigmy.jpg" alt="image-20201219212804466"></p>
</li>
<li><p>四种文法：<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu5596nrzj30xo0ikacg.jpg" alt="image-20201220110436053"></p>
</li>
<li><p>0型文法也称为短语文法:一个非常重要的理论结果是，0型文法的能力相当于图灵机（Turing）</p>
</li>
<li><p>1型文法（上下文有关文法）：A只有出现在α1α2的上下文中，才允许用β替换。</p>
</li>
<li><p>2型文法(CFG):即β取代A时，与A所处的上下文无关。（程序设计语言的多数语法</p>
</li>
<li><p>3型文法(RG)：也称正规文法</p>
<ul>
<li><p>每个产生式均为 “A→aB”或“A→a” —— 右线性</p>
<p>  　　 “A→Ba”或“A→a” —— 左线性</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CFG的语法树及二义性</p>
<ul>
<li>短语：语法树每一层的所有叶结点</li>
<li>直接短语：该子树不能再推出其它短语</li>
<li>句柄：最左边的直接短语</li>
<li>二义性：语法树唯一</li>
</ul>
</li>
</ul>
</li>
<li><p>难点：</p>
<ul>
<li>程序设计语言的语义定义</li>
</ul>
</li>
</ul>
<h3 id="3-词法分析-1"><a href="#3-词法分析-1" class="headerlink" title="3.词法分析"></a>3.词法分析</h3><ul>
<li>重点<ul>
<li>词法分析器的输入、输出<ul>
<li>输入源程序，输出单词符号(token)</li>
</ul>
</li>
<li>用于识别符号的状态转移图的构造<ul>
<li>有穷自动机<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glud8jamfwj314w0kadmc.jpg" alt="image-20201220154432277"></li>
</ul>
</li>
<li>根据状态转移图实现词法分析器</li>
</ul>
</li>
<li>难点<ul>
<li>词法的正规文法表示、正规表达式表示、状态转移图表示，它们之间的转换。 <ul>
<li><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu5zginv5j319q0hiacy.jpg" alt="image-20201219223422025"></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-自顶向下的语法分析"><a href="#4-自顶向下的语法分析" class="headerlink" title="4.自顶向下的语法分析"></a>4.自顶向下的语法分析</h3><ul>
<li>重点<ul>
<li>自顶向下分析的基本思想：<ul>
<li>递归子程序法（从根开始构建整棵树）</li>
<li>预测分析法(LL(1))</li>
</ul>
</li>
<li>预测分析器总体结构，预测分析表的构造，递归下降分析法基本思想，简单算术表达式的递归下降分析器。</li>
</ul>
</li>
<li>难点<ul>
<li>FIRST 和 FOLLOW 集的求法，<ul>
<li><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glufka7em5j30z70u04qp.jpg" alt="image-20201220170458995"></li>
</ul>
</li>
<li>对它们的理解以及在构造LL(1)分析表时的使用。递归子程序法中如何体现分析的结果。</li>
</ul>
</li>
</ul>
<h3 id="5-自底向上的语法分析"><a href="#5-自底向上的语法分析" class="headerlink" title="5.自底向上的语法分析"></a>5.自底向上的语法分析</h3><ul>
<li>重点<ul>
<li>自底向上分析的基本思想：从输入串出发，反复利用产生式进行归约，如果最后能得到文法的开始符号，则输入串是句子，否则输入串有语法错误。</li>
<li>算符优先分析法的基本思想，简单算符优先分析法。LR 分析器的基本构造思想，LR分析算法，规范句型活前缀及其识别器——DFA，LR(0)分析表的构造，SLR(1)分析表的构造, LR(1)分析表的构造。</li>
</ul>
</li>
<li>难点<ul>
<li>求FIRSTOP 和LASTOP，算符优先关系的确定，算符优先分析表的构造，素短语与最左素短语的概念。规范句型活前缀，LR(0)项目集闭包与项目集规范族，它们与句柄识别的关系，活前缀与句柄的关系, LR(1)项目集闭包与项目集规范族。 </li>
</ul>
</li>
</ul>
<h3 id="6-语法制导翻译与属性文法"><a href="#6-语法制导翻译与属性文法" class="headerlink" title="6.语法制导翻译与属性文法"></a>6.语法制导翻译与属性文法</h3><ul>
<li>重点<ul>
<li>语法制导翻译：语法分析中进行静态语义检查和中间代码生成的技术称为语法制导翻译技术</li>
<li>语法制导定义：为了通过将语义属性关联到文法符号、将语义规则关联到产生式，有效地将语法和语义关联起来，人们引入了语法制导定义，没有副作用的语法制导定义又称为属性文法</li>
<li>翻译模式：如果不仅将语义属性关联到文法符号、将语义规则关联到产生式，而且还通过将语义动作嵌入到产生式的适当位置来表达该语义动作的执行时机，这就是翻译模式。翻译模式给语义分析的实现提供了更好的支持。</li>
<li>自顶向下翻译，自底向上翻译。</li>
</ul>
</li>
<li>难点<ul>
<li>属性的意义：为相应的语法成分设置表示语义的属性，属性的值是可以计算的，根据属性值计算的关联关系，将其分成综合属性和继承属性，根据属性文法中所含的属性将属性文法分成<em>S</em>-属性文法和<em>L</em>-属性文法。</li>
<li>对综合属性，继承属性，固有属性的理解，属性计算，怎么通过属性来表达翻译。</li>
</ul>
</li>
</ul>
<h3 id="7-语义分析与中间代码生成"><a href="#7-语义分析与中间代码生成" class="headerlink" title="7.语义分析与中间代码生成"></a>7.语义分析与中间代码生成</h3><ul>
<li>重点<ul>
<li>三地址码：是指这种代码的每条指令最多只能包含三个地址，即两个操作数地址和一个结果地址。</li>
<li>各种语句的目标代码结构、语法制导定义与翻译模式。</li>
</ul>
</li>
<li>难点<ul>
<li>布尔表达式的翻译<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glumljhu9aj319e0mk784.jpg" alt="image-20201220210826008"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glv8sr0o6nj30jm0ouq4x.jpg" alt="image-20201220210803201"></li>
<li>对各种语句的目标代码结构、语法制导定义与翻译模式的理解。</li>
</ul>
</li>
</ul>
<h3 id="9-运行时的存储组织"><a href="#9-运行时的存储组织" class="headerlink" title="9.运行时的存储组织"></a>9.运行时的存储组织</h3><ul>
<li>重点<ul>
<li>符号表的内容、组织，过程调用实现，静态存储分配、动态存储分配的基本方法。</li>
</ul>
</li>
<li>难点<ul>
<li>参数传递，过程说明语句代码结构，过程调用语句的代码结构，过程调用语句的语法制导定义，栈式存储分配。 </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（四）进程</title>
    <url>/2020/11/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="一、进程的定义"><a href="#一、进程的定义" class="headerlink" title="一、进程的定义"></a>一、进程的定义</h2><p>程序段、数据段、PCB三部分组成了进程实体，PCB是进程存在的唯一标志，用来描述进程的各种信息。</p>
<h3 id="典型定义："><a href="#典型定义：" class="headerlink" title="典型定义："></a>典型定义：</h3><p>进程是程序的一次执行过程</p>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p>
<h2 id="二、进程的组成"><a href="#二、进程的组成" class="headerlink" title="二、进程的组成"></a>二、进程的组成</h2><ul>
<li><h3 id="PCB："><a href="#PCB：" class="headerlink" title="PCB："></a>PCB：</h3><ul>
<li>进程描述信息：进程标识符PID、用户标识符UID</li>
<li>进程控制和管理信息：进程当前状态、进程优先级</li>
<li>资源分配清单：程序段指针、数据段指针、键盘、鼠标</li>
<li>处理机相关信息：各种寄存器值</li>
</ul>
</li>
<li><h3 id="程序段："><a href="#程序段：" class="headerlink" title="程序段："></a>程序段：</h3><ul>
<li>存放要执行的代码</li>
</ul>
</li>
<li><h3 id="数据段："><a href="#数据段：" class="headerlink" title="数据段："></a>数据段：</h3><ul>
<li>存放程序运行过程中处理的各种数据</li>
</ul>
</li>
</ul>
<h2 id="三、进程的组织"><a href="#三、进程的组织" class="headerlink" title="三、进程的组织"></a>三、进程的组织</h2><p>多个进程之间的组织方式问题</p>
<ul>
<li><h3 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h3><ul>
<li>按照进程状态将PCB分为多个队列<ul>
<li>执行指针-&gt;当前处于运行态的进程（单CPU中，只有一个进程在同一时刻运行）</li>
<li>就绪队列指针-&gt;处于就绪态的进程（为一个队列，优先级高的在前）</li>
<li>阻塞队列指针-&gt;处于阻塞态的进程（可能有多个阻塞队列）</li>
</ul>
</li>
<li>操作系统持有指向各个队列的指针</li>
</ul>
</li>
<li><h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><ul>
<li>根据进程状态的不同，建立几张索引表</li>
<li>操作系统持有指向各个索引表的指针</li>
</ul>
</li>
</ul>
<h2 id="四、进程的特征"><a href="#四、进程的特征" class="headerlink" title="四、进程的特征"></a>四、进程的特征</h2><ol>
<li>动态性：进程是动态的、变化的、消亡的</li>
<li>并发性：内存中有多个进程实体，各进程可并发执行</li>
<li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li>异步性：并发执行的进程的结果的完成速度的不确定性，操作系统需要提供“进程同步机制”来解决异步问题</li>
<li>结构性：每个进程都配备一个PCB，结构上由数据段、代码段、PCB组成</li>
</ol>
<h2 id="五、进程的状态"><a href="#五、进程的状态" class="headerlink" title="五、进程的状态"></a>五、进程的状态</h2><h3 id="1-三种基本状态："><a href="#1-三种基本状态：" class="headerlink" title="1. 三种基本状态："></a>1. 三种基本状态：</h3><ul>
<li>运行态：占用CPU<ul>
<li>CPU✅其它所需资源✅</li>
</ul>
</li>
<li>就绪态：可以运行，但CPU被其它进程占用<ul>
<li>CPU❌其它所需资源✅</li>
</ul>
</li>
<li>阻塞态：等待某一事件的完成而暂时无法运行<ul>
<li>CPU❌其它所需资源❌</li>
</ul>
</li>
</ul>
<h3 id="2-另外两种状态："><a href="#2-另外两种状态：" class="headerlink" title="2.另外两种状态："></a>2.另外两种状态：</h3><ul>
<li>创建态：操作系统为进程分配资源、初始化PCB</li>
<li>终止态：进程从操作系统中撤销，操作系统回收进程资源，撤销PCB</li>
</ul>
<h3 id="3-进程的状态转换"><a href="#3-进程的状态转换" class="headerlink" title="3.进程的状态转换"></a>3.进程的状态转换</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl2d2mq7nvj31go0nugqd.jpg" alt="image-20201126102303056"></p>
<p>注意：运行态-&gt;阻塞态是进程自身的主动行为</p>
<p>​           阻塞态-&gt;就绪态是被动的，阻塞态不能直接转换为运行态</p>
<h2 id="六、进程控制"><a href="#六、进程控制" class="headerlink" title="六、进程控制"></a>六、进程控制</h2><h3 id="1-实现的方式："><a href="#1-实现的方式：" class="headerlink" title="1.实现的方式："></a>1.实现的方式：</h3><p>用原语来实现进程的控制，其特点是执行期间不允许中断（原子操作），可以保证进程转换时PCB不会发生混乱（保证进程转换的过程完整发生，而不被其它中断打断，原语运行在核心态中，采用“关中断指令”和“开中断指令”，权限极大是核心态下执行的特权指令）</p>
<h3 id="2-控制的内容："><a href="#2-控制的内容：" class="headerlink" title="2.控制的内容："></a>2.控制的内容：</h3><ul>
<li>更新PCB中的信息</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ul>
<h2 id="七、进程通信"><a href="#七、进程通信" class="headerlink" title="七、进程通信"></a>七、进程通信</h2><p>进程间的信息交换</p>
<h3 id="1-共享存储"><a href="#1-共享存储" class="headerlink" title="1. 共享存储"></a>1. 共享存储</h3><p>两个进程对共享空间的访问必须是<strong>互斥</strong>的（操作系统只负责提供共享空间和同步互斥工具）</p>
<ul>
<li>基于数据结构的共享<ul>
<li>速度慢、限制多，是一种低级通信方式</li>
</ul>
</li>
<li>基于储存区的共享<ul>
<li>数据的形式和存放位置都由进程控制，速度更快，是一种高级通信方式</li>
</ul>
</li>
</ul>
<h3 id="2-管道通信"><a href="#2-管道通信" class="headerlink" title="2.管道通信"></a>2.管道通信</h3><p>在内存中开辟一个大小固定的缓存区</p>
<ul>
<li>管道只能采用<strong>半双工</strong>通信，某一时间段只能实现单向的传输，要实现双向同时通信，需要两个管道</li>
<li>各进程<strong>互斥</strong>地形式访问管道</li>
<li>数据以字符流的形式写入管道，当管道写满时，写进程的write()将被阻塞，等待读进程。当读进程将数据全部取走后，管道变空，此时读进程的read()将被阻塞</li>
<li>如果<strong>没写满，就不允许读</strong>，如果<strong>没读空，就不允许写</strong></li>
<li>数据一旦被读出，就从管道中被抛弃，这就意味着读<strong>进程最多只能有一个</strong>，否则可能会有读错数据的情况。</li>
</ul>
<h3 id="3-消息传递"><a href="#3-消息传递" class="headerlink" title="3.消息传递"></a>3.消息传递</h3><p>进程间的数据交换以<strong>格式化的消息</strong>为单位。通过操作系统提供的“发消息/接受消息”两个<strong>原语</strong>进行数据交换</p>
<p>消息由<strong>消息头</strong>和<strong>消息体</strong>组成：消息头包括发送进程ID、接受进程ID、消息类型、消息长度等格式化信息（计网中的“报文”就是一种<strong>格式化</strong>的消息）</p>
<ul>
<li>直接通信方式：消息直接挂到接收进程的消息缓冲队列上</li>
<li>间接通信方式：消息先发送到中间实体（信箱）中，也称信箱通信方式</li>
</ul>
<h2 id="八、进程互斥"><a href="#八、进程互斥" class="headerlink" title="八、进程互斥"></a>八、进程互斥</h2><p>实现对临界资源的互斥访问</p>
<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
<h3 id="Peterson算法："><a href="#Peterson算法：" class="headerlink" title="Peterson算法："></a>Peterson算法：</h3><p>结合双标志后检查法和单标志法，定义一个布尔数组和一个轮转标志，同时检查这两个标志，优先让对方先使用临界资源</p>
<h3 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">bool</span> *lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>; <span class="comment">// 上锁</span></span><br><span class="line">    <span class="keyword">return</span> old; <span class="comment">// 返回上锁前的状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TSL指令实现</span></span><br><span class="line"><span class="keyword">while</span>(TestAndSet(&amp;lock));<span class="comment">// 不停上锁，直到发现某一次临界资源并未被上锁</span></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line">lock = <span class="literal">false</span>; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<h3 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h3><p>交换old和lock的值来实现锁</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（五）调度算法</title>
    <url>/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="1-FCFS（First-Come-First-Serve）"><a href="#1-FCFS（First-Come-First-Serve）" class="headerlink" title="1.FCFS（First Come First Serve）"></a>1.FCFS（First Come First Serve）</h2><p>先到先服务，非抢占式</p>
<ul>
<li>优点：算法简单易实现，公平</li>
<li>缺点：对长作业有利，对短作业不利</li>
</ul>
<h2 id="2-SJF（Shortest-Job-First）"><a href="#2-SJF（Shortest-Job-First）" class="headerlink" title="2.SJF（Shortest Job First）"></a>2.SJF（Shortest Job First）</h2><p>短进程先进性，分为抢占式和非抢占式</p>
<ul>
<li>最短的平均等待时间，平均周转时间</li>
<li>对短作业有利，长作业不利，可能产生饥饿</li>
</ul>
<h2 id="3-HRRN（Highest-Response-Ration-Next"><a href="#3-HRRN（Highest-Response-Ration-Next" class="headerlink" title="3.HRRN（Highest Response Ration Next)"></a>3.HRRN（Highest Response Ration Next)</h2><p>每次调度时计算响应比（$\frac{等待时间+要求服务时间}{要求服务时间}$），选择响应比最高的进行服务，一般为非抢占式</p>
<h2 id="4-时间片轮转（RR，Round-Robin）"><a href="#4-时间片轮转（RR，Round-Robin）" class="headerlink" title="4.时间片轮转（RR，Round-Robin）"></a>4.时间片轮转（RR，Round-Robin）</h2><p>公平的轮流为各个进程服务，抢占式</p>
<ul>
<li>优点：公平，适用于分时操作系统</li>
<li>缺点：进程切换导致有一定开销，且不区分紧急程度</li>
</ul>
<h2 id="5-优先级调服算法"><a href="#5-优先级调服算法" class="headerlink" title="5.优先级调服算法"></a>5.优先级调服算法</h2><p>调度时选择最高优先级的活动，非抢占式和抢占式</p>
<ul>
<li>优点：适用于实时操作系统</li>
<li>缺点：可能导致饥饿</li>
</ul>
<h2 id="6-多级反馈队列调度算法"><a href="#6-多级反馈队列调度算法" class="headerlink" title="6.多级反馈队列调度算法"></a>6.多级反馈队列调度算法</h2>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络（二）性能指标</title>
    <url>/2020/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><h2 id="一、速率"><a href="#一、速率" class="headerlink" title="一、速率"></a>一、速率</h2><p>速率即数据率或称数据传输率或者比特率（比特：1/0 位）</p>
<p><strong><em>区分速率的单位和储存容量的单位</em></strong>     (1Byte = 8bit)<br>$$<br>\begin{aligned}<br>速率：&amp;1Tb/s &amp;=&amp; 10^3Gb &amp;=&amp; 10^6Mb/s &amp;=&amp; 10^9kb/s &amp;=&amp; 10^{12}b/s<br>\储存容量：&amp;1TB &amp;=&amp; 2^{10}GB &amp;=&amp; 2^{20}MB &amp;=&amp; 2^{30}KB &amp;=&amp; 2^{40}B \quad\quad = 2^{40}*8b<br>\end{aligned}<br>$$</p>
<h2 id="二、带宽"><a href="#二、带宽" class="headerlink" title="二、带宽"></a>二、带宽</h2><p>“带宽”原本指，某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）</p>
<p>计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的<strong>最高数据率</strong>，单位是“比特每秒”</p>
<p>指的是网络设备所支持的最高速度，因为信号在链路中的传播速度是一样的，都是光速，不同的只是设备单位时间可以发出的比特的个数</p>
<h2 id="三、吞吐量"><a href="#三、吞吐量" class="headerlink" title="三、吞吐量"></a>三、吞吐量</h2><p>表示在单位时间内通过某个网络（或信道、接口）的数据量。单位“比特每秒”</p>
<p>吞吐量和带宽的区别：吞吐量是带宽的实际情况，带宽是吞吐量的理论上限</p>
<h2 id="四、时延"><a href="#四、时延" class="headerlink" title="四、时延"></a>四、时延</h2><p>指数据从网络的一端传送到另一端所需的时间，单位是秒</p>
<ul>
<li>发送时延:$\frac{数据长度}{信道带宽（发送速率）}$</li>
<li> 传播时延：$\frac{信道长度}{电磁波在信道上的传播速率}$</li>
<li>排队时延：等待输出/输入链路可用</li>
<li>处理时延：检错，找出口</li>
</ul>
<h2 id="五、时延带宽积"><a href="#五、时延带宽积" class="headerlink" title="五、时延带宽积"></a>五、时延带宽积</h2><p>时延带宽积 = 传播时延 X 带宽        单位：bit</p>
<p>又称<strong>比特为单位的链路长度</strong>，即<strong>某段链路现在有多少比特</strong></p>
<h2 id="六、往返时延RTT"><a href="#六、往返时延RTT" class="headerlink" title="六、往返时延RTT"></a>六、往返时延RTT</h2><p>从发送方发送数据开始，到接收方收到接收方的确认（接收方收到数据后立即发送确认）总共经历的时延</p>
<p>RTT包括</p>
<ul>
<li>往返时延 = 传播时延 X 2</li>
<li>末端处理时间</li>
</ul>
<h2 id="七、利用率"><a href="#七、利用率" class="headerlink" title="七、利用率"></a>七、利用率</h2><ul>
<li>信道利用率：$\frac{有数据通过时间}{（有+无）数据通过时间}$</li>
<li>网络利用率：信道利用率</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络（三）分层结构</title>
    <url>/2020/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="计算机网络的分层结构"><a href="#计算机网络的分层结构" class="headerlink" title="计算机网络的分层结构"></a>计算机网络的分层结构</h1><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><h3 id="为什么分层："><a href="#为什么分层：" class="headerlink" title="为什么分层："></a>为什么分层：</h3><ul>
<li>激活数据通路</li>
<li>告诉网络如何识别目的主机</li>
<li>查明目的主机状态</li>
<li>弄清楚目的主机的文件管理系统是否准备好</li>
<li>确保差错和意外可以解决</li>
</ul>
<h3 id="分层结构："><a href="#分层结构：" class="headerlink" title="分层结构："></a>分层结构：</h3><ul>
<li>协议：为进行网络中的对等实体数据交换而建立的规则、标准或约定称为网络协议<ul>
<li>语法：规定传送数据的格式</li>
<li>语义：规定所要完成的功能</li>
<li>同步：规定各种操作的顺序</li>
</ul>
</li>
<li>接口：上层使用下层服务的入口（仅在<strong>相邻层有接口</strong>，且所提供服务的具体细节对上一层完全屏蔽</li>
<li>服务：下层为上层提供的功能调用</li>
</ul>
<h3 id="分层的基本原则："><a href="#分层的基本原则：" class="headerlink" title="分层的基本原则："></a>分层的基本原则：</h3><ul>
<li>各层相互<strong>独立</strong>，每层只实现一种相对独立的功能</li>
<li>各层之间<strong>界面自然清晰</strong>，相互交流尽可能少</li>
<li>结构上可分割，<strong>每层都采用最合适的技术来实现</strong></li>
<li>保持上下层独立性，<strong>上层单向使用下层提供的服务</strong></li>
<li>分层结构能够促进标准化工作</li>
</ul>
<h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p>7层的法定标准</p>
<p>目的：支持异构网络系统的互联互通</p>
<p>结构：</p>
<ul>
<li>通信子网（数据通信）（中间系统）<ul>
<li>1.物理层：在物理媒体上实现比特流的传输<ul>
<li>定义接口特性</li>
<li>定义传输模式：单工、半双工、双工</li>
<li>定义传输速率</li>
<li>比特同步</li>
<li>比特编码</li>
</ul>
</li>
<li>2.数据链路层：把网络层的数据报组装成帧<ul>
<li>成帧：定义帧的开始和结束</li>
<li>差错控制：帧错+位错</li>
<li>流量控制</li>
<li>访问/接入控制：控制对信道的访问</li>
</ul>
</li>
<li>3.网络层<ul>
<li>路由选择，选择最佳路径</li>
<li>流量控制：协调速度</li>
<li>差错控制：检查错误</li>
<li>拥塞控制：宏观控制整个网络的拥塞状态</li>
</ul>
</li>
</ul>
</li>
<li>4.传输层：负责主机中两个进程的通信，功能：可靠传输、不可靠传输，差错控制，流量控制，复用分用</li>
<li>资源子网（数据处理）<ul>
<li>5.会话层：向表示层提供建立连接并有序地传输数据<ul>
<li>建立，管理，终止会话</li>
<li>插入校验点用来恢复通信</li>
</ul>
</li>
<li>6.表示层：处理两个通信系统中交换信息的表示方式<ul>
<li>数据格式变换</li>
<li>数据加密解密</li>
<li>数据压缩与恢复</li>
</ul>
</li>
<li>7.应用层：产生网络交互的应用</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程</title>
    <url>/2020/11/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是软件工程？"><a href="#什么是软件工程？" class="headerlink" title="什么是软件工程？"></a>什么是软件工程？</h3><p>用来制造软件的工程化方法</p>
<h3 id="什么是软件？"><a href="#什么是软件？" class="headerlink" title="什么是软件？"></a>什么是软件？</h3><p>程序：是为实现特定目标或解决特定问题而用计算机语言编写的命令序列的集合</p>
<p>软件：软件是程序、数据以及开发、使用和维护所需要的所有文档的总称</p>
<p>软件 = 程序 + 数据 + 文档</p>
<h3 id="软件的本质特性："><a href="#软件的本质特性：" class="headerlink" title="软件的本质特性："></a>软件的本质特性：</h3><p>复杂度、一致性、可变（演化）性和不可见性</p>
<h3 id="软件开发面临的挑战"><a href="#软件开发面临的挑战" class="headerlink" title="软件开发面临的挑战"></a>软件开发面临的挑战</h3><ul>
<li>客户不满意</li>
<li>风险与成本问题</li>
<li>项目过程失控</li>
<li>无力管理团队</li>
</ul>
<h3 id="什么是工程化的方法？"><a href="#什么是工程化的方法？" class="headerlink" title="什么是工程化的方法？"></a>什么是工程化的方法？</h3><p>工程是将理论和所学的知识应用于实践的科学，以便经济有效地解决实际问题</p>
<h3 id="工程化思想"><a href="#工程化思想" class="headerlink" title="工程化思想"></a>工程化思想</h3><ul>
<li>分而治之</li>
<li>折中</li>
<li>复用</li>
</ul>
<h3 id="软件工程的内容"><a href="#软件工程的内容" class="headerlink" title="软件工程的内容"></a>软件工程的内容</h3><ul>
<li>工具</li>
<li>方法</li>
<li>过程</li>
<li>质量关注点</li>
</ul>
<h3 id="软件工程过程"><a href="#软件工程过程" class="headerlink" title="软件工程过程"></a>软件工程过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	A[问题定义]--&gt;B[需求开发]</span><br><span class="line">	B--&gt;C[软件设计]</span><br><span class="line">	C--&gt;D[软件实现]</span><br><span class="line">	D--&gt;E[软件测试]</span><br></pre></td></tr></table></figure>

<h2 id="软件项目开发过程与管理"><a href="#软件项目开发过程与管理" class="headerlink" title="软件项目开发过程与管理"></a>软件项目开发过程与管理</h2><h3 id="软件开发过程的典型阶段"><a href="#软件开发过程的典型阶段" class="headerlink" title="软件开发过程的典型阶段"></a>软件开发过程的典型阶段</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	A[计划]--&gt;B[需求分析]</span><br><span class="line">	B--&gt;C[软件设计]</span><br><span class="line">	C--&gt;D[软件实现]</span><br><span class="line">	D--&gt;E[软件验证]</span><br><span class="line">	E--&gt;F[软件维护]</span><br></pre></td></tr></table></figure>

<h3 id="典型软件过程模型"><a href="#典型软件过程模型" class="headerlink" title="典型软件过程模型"></a>典型软件过程模型</h3><ul>
<li>瀑布模型：线性，需要要求明确，上一阶段输出是下一阶段输入，难以修改</li>
<li>增量过程模型<ul>
<li>增量模型：本质是以迭代的方式运用瀑布模型</li>
<li>快速应用程序开发（RAD）：瀑布模型的高速变体，并行运行，侧重短周期</li>
</ul>
</li>
<li>演化过程模型<ul>
<li>快速原型开发模型：循环反复，不断调整，原型可抛弃</li>
<li>螺旋模型：将软件生存周期分为四个可重复的阶段：规划、风险分析、开发和评估</li>
</ul>
</li>
</ul>
<h3 id="软件管理的基本概念："><a href="#软件管理的基本概念：" class="headerlink" title="软件管理的基本概念："></a>软件管理的基本概念：</h3><ul>
<li>项目：进行定义的一组活动，使用受约束的资源来满足预定义的目标</li>
<li>项目管理：有效的组织和管理各类资源，以使项目能够在预定的范围、质量、时间和成本等约束条件下顺利交付</li>
</ul>
<h3 id="软件项目的特征"><a href="#软件项目的特征" class="headerlink" title="软件项目的特征"></a>软件项目的特征</h3><ul>
<li>软件产品的不可见性</li>
<li>项目的高度不确定性</li>
<li>软件过程的多变性</li>
<li>软件人员的高技能及其高流动性</li>
</ul>
<h3 id="项目估算的内容"><a href="#项目估算的内容" class="headerlink" title="项目估算的内容"></a>项目估算的内容</h3><ul>
<li>规模估算</li>
<li>工作量估算</li>
<li>进度估算</li>
<li>成本估算</li>
</ul>
<p>估算的风险取决于资源、成本及进度的定量估算中存在的不确定性</p>
<h3 id="代码行技术"><a href="#代码行技术" class="headerlink" title="代码行技术"></a>代码行技术</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksg344szpj30v00dejsz.jpg" alt="image-20201117203134488"></p>
<h2 id="软件需求工程"><a href="#软件需求工程" class="headerlink" title="软件需求工程"></a>软件需求工程</h2><h3 id="用户故事"><a href="#用户故事" class="headerlink" title="用户故事"></a>用户故事</h3><p>格式：作为一个&lt;角色&gt;，可以&lt;活动&gt;，以便于&lt;价值&gt;</p>
<h3 id="需求规格说明书（SRS）"><a href="#需求规格说明书（SRS）" class="headerlink" title="需求规格说明书（SRS）"></a>需求规格说明书（SRS）</h3><ul>
<li>功能</li>
<li>外部接口</li>
<li>性能</li>
<li>非功能属性</li>
<li>约束条件</li>
</ul>
<h3 id="SRS的三大部分"><a href="#SRS的三大部分" class="headerlink" title="SRS的三大部分"></a>SRS的三大部分</h3><ul>
<li>引言</li>
<li>整体描述</li>
<li>需求描述</li>
</ul>
<h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="软件工程方法"><a href="#软件工程方法" class="headerlink" title="软件工程方法"></a>软件工程方法</h3><ul>
<li>功能分解法</li>
<li>结构化方法</li>
<li>信息建模法</li>
<li>面向对象法</li>
</ul>
<h3 id="软件体系结构"><a href="#软件体系结构" class="headerlink" title="软件体系结构"></a>软件体系结构</h3><ul>
<li>构件</li>
<li>连接件</li>
<li>约束</li>
</ul>
<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>不考虑程序内部逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksiqhnruvj30o00d2jsb.jpg" alt="image-20201117220318785"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksjbm31o4j30ia0ckmyr.jpg" alt="image-20201117222337336"></p>
<h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksis3gc08j30hw0comyc.jpg" alt="image-20201117220451687"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksj0xkp6xj31ak0pmq8q.jpg" alt="image-20201117221320972"></p>
]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
</search>
