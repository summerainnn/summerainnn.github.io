<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode：21.合并两个有序链表</title>
    <url>/2020/11/08/Leetcode%EF%BC%9A21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">Leetcode</a></h3><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><ul>
<li>时间复杂度为o（m+n）</li>
<li>空间复杂度o（m+n）这是递归调用的深度，即最多调用m+n次</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><ul>
<li>时间复杂度o（m+n）</li>
<li>空间复杂度o（1），仅需要常数个node作为临时储存</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode answer = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode temp = answer;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                temp.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = l1==<span class="keyword">null</span>? l2:l1;</span><br><span class="line">        <span class="keyword">return</span> answer.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>合并</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode：26.删除排序数组中的重复项</title>
    <url>/2020/11/08/leetcode%EF%BC%9A26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26.删除排序数组中的重复项"></a>26.删除排序数组中的重复项</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">Leetcode</a></h3><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><ul>
<li>快慢两个指针，前一个用来计数，后一个用来遍历数组，在找到不同数字后进行交换</li>
<li>时间复杂度o（n），空间复杂度o（1）</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j];<span class="comment">//存在此时i==j的情况，可优化</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
        <tag>重复</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现爬取豆瓣电影评论</title>
    <url>/2020/11/10/python%E5%AE%9E%E7%8E%B0%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="python实现爬取豆瓣电影评论"><a href="#python实现爬取豆瓣电影评论" class="headerlink" title="python实现爬取豆瓣电影评论"></a>python实现爬取豆瓣电影评论</h1><h2 id="github"><a href="#github" class="headerlink" title="github"></a><a href="https://github.com/summerainnn/dbSpider">github</a></h2><h2 id="使用的库"><a href="#使用的库" class="headerlink" title="使用的库"></a>使用的库</h2><p>以前在写爬虫时使用的都是reques，这次发现了更好用的request_html，不需要再用bs4来解析网页了</p>
<blockquote>
<p>request_html</p>
</blockquote>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>首先建立一个会话（session），即让Python作为一个客户端，和远端服务器交谈</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">session = HTMLSession()</span><br></pre></td></tr></table></figure>

<p>然后就可以用session来进行get的操作，这里的URL可以自己在浏览器中寻找，找到你需要的数据的具体的get的网址，该网址并不一定是网页网址</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><a href="https://pypi.org/project/requests-html/">官方文档</a></h3><h3 id="如何用Python爬数据？（一）网页抓取"><a href="#如何用Python爬数据？（一）网页抓取" class="headerlink" title="如何用Python爬数据？（一）网页抓取"></a><a href="https://www.jianshu.com/p/ba02079ecd2f">如何用Python爬数据？（一）网页抓取</a></h3><h3 id="requests-html"><a href="#requests-html" class="headerlink" title="requests-html"></a><a href="https://www.jianshu.com/p/380974ba9540">requests-html</a></h3>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>应用</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能</title>
    <url>/2020/11/15/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
    <content><![CDATA[<h1 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h1><h2 id="什么是人工智能？"><a href="#什么是人工智能？" class="headerlink" title="什么是人工智能？"></a>什么是人工智能？</h2><ul>
<li>类人类思维方法：认知模型方法</li>
<li>类人行为方法：图灵测试</li>
<li>理性思维方法：思维法则</li>
<li>理性行为方法：理性智能体</li>
</ul>
<p>一般解释：用人工的方法在机器（计算机）上实现的智能</p>
<h2 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h2><h3 id="产生式表达法"><a href="#产生式表达法" class="headerlink" title="产生式表达法"></a>产生式表达法</h3><h4 id="事实的表示"><a href="#事实的表示" class="headerlink" title="事实的表示"></a>事实的表示</h4><h5 id="确定性知识表示"><a href="#确定性知识表示" class="headerlink" title="确定性知识表示"></a>确定性知识表示</h5><ul>
<li>（对象，属性，值） 例如：（雪，颜色，白）</li>
<li>（关系，对象1，对象2） 例如（热爱，汪峰，祖国）</li>
</ul>
<h5 id="非确定性知识："><a href="#非确定性知识：" class="headerlink" title="非确定性知识："></a>非确定性知识：</h5><ul>
<li>（对象，属性，值，可信度因子）</li>
</ul>
<h4 id="规则的表示"><a href="#规则的表示" class="headerlink" title="规则的表示"></a>规则的表示</h4><p>P -&gt; Q     IF P THEN Q</p>
<h3 id="语义网络表示法"><a href="#语义网络表示法" class="headerlink" title="语义网络表示法"></a>语义网络表示法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[节点1]--&gt;|语义关系|B[节点2] </span><br></pre></td></tr></table></figure>

<h4 id="基本语义关系"><a href="#基本语义关系" class="headerlink" title="基本语义关系"></a>基本语义关系</h4><ul>
<li>实例关系：ISA（是一个）</li>
<li>分类关系：AKO（是一种）</li>
<li>成员关系：A-Member-of（是一员）</li>
<li>聚类关系：Part-of（是一部分）</li>
<li>属性关系：<ul>
<li>Have（有） </li>
<li>Can（能，会）</li>
</ul>
</li>
<li>时间关系：<ul>
<li>Before（在前）</li>
<li>After（在后）</li>
</ul>
</li>
<li>位置关系：Locate-on（在···上面）</li>
<li>相近关系：Similar-to（相似）Near-to（接近）</li>
</ul>
<h3 id="框架表示法"><a href="#框架表示法" class="headerlink" title="框架表示法"></a>框架表示法</h3><h4 id="框架的结构："><a href="#框架的结构：" class="headerlink" title="框架的结构："></a>框架的结构：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Frame&lt;框架名&gt;</span><br><span class="line">槽名A：侧面名A1		值A11	值A12</span><br><span class="line">			侧面名A2		值A21  值A22</span><br><span class="line">槽名B：侧面名B1		值B11	值B12</span><br><span class="line">			侧面名A2		值B21  值B22</span><br></pre></td></tr></table></figure>

<h2 id="推理的分类"><a href="#推理的分类" class="headerlink" title="推理的分类"></a>推理的分类</h2><h4 id="演绎推理"><a href="#演绎推理" class="headerlink" title="演绎推理"></a>演绎推理</h4><p>常用形式：三段论</p>
<p>不能增值新知识</p>
<h4 id="归纳推理"><a href="#归纳推理" class="headerlink" title="归纳推理"></a>归纳推理</h4><p>从个别到一般的推理</p>
<p>可以增值新知识</p>
]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer：03.数组中的重复元素</title>
    <url>/2020/11/08/%E5%89%91%E6%8C%87%20Offer%EF%BC%9A03-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="剑指-Offer：03-数组中的重复元素"><a href="#剑指-Offer：03-数组中的重复元素" class="headerlink" title="剑指 Offer：03:数组中的重复元素"></a>剑指 Offer：03:数组中的重复元素</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<h3 id="Leetcoed"><a href="#Leetcoed" class="headerlink" title="Leetcoed"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">Leetcoed</a></h3><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="对原数组进行改变"><a href="#对原数组进行改变" class="headerlink" title="对原数组进行改变"></a>对原数组进行改变</h3><ul>
<li>实现复杂度为o（n），空间复杂度为o（1）</li>
</ul>
<ul>
<li>此处可对所有的重复数字进行查找</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                <span class="keyword">if</span>(nums[temp]==nums[i])&#123;</span><br><span class="line">                    answer[index] = nums[i];</span><br><span class="line">                    index++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[i] = nums[temp];</span><br><span class="line">                nums[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        answer[<span class="number">0</span>] = index-<span class="number">1</span>;<span class="comment">//用answer的第一个空间存储重复元素个数，可以实现多元素查找</span></span><br><span class="line">        <span class="keyword">return</span> answer[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="不改变原数组"><a href="#不改变原数组" class="headerlink" title="不改变原数组"></a>不改变原数组</h3><ul>
<li><p>用辅助数组进行，牺牲空间复杂度为o（n），时间复杂度仍为o（n）</p>
</li>
<li><p>用二分法可以将空间复杂度变为o（1），但时间复杂度为o（nlogn）<strong>（仅可查找一个重复元素，同时该方法要求数组元素的数量比所有数字的数量更大）</strong></p>
</li>
<li><p>使用HashSet同样可以实现时间复杂度为o（n）的解法，同时不用改变原数组</p>
</li>
</ul>
<p><em>HashSet是通过HashMap实现的一个不包含重复元素的集合，且没有key-value的对应关系</em></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; dic = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dic.add(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
        <tag>重复</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer：04.二维数组中的查找</title>
    <url>/2020/11/09/%E5%89%91%E6%8C%87%20Offer%EF%BC%9A04.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="剑指-Offer：04-二维数组中的查找"><a href="#剑指-Offer：04-二维数组中的查找" class="headerlink" title="剑指 Offer：04.二维数组中的查找"></a>剑指 Offer：04.二维数组中的查找</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">Leetcode</a></h3><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>根据该数组的特点，可从数组的右上角或者左下角开始，进行求解</li>
<li>专注于当前点，而不是下一个点，因为根据当前点即可判断出下一个点的位置，这也是初始点选择的好处所在</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = columns-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row&lt;rows&amp;&amp;column&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = matrix[row][column];</span><br><span class="line">            <span class="keyword">if</span>(num==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;target)&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                column--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
        <tag>线性查找</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer：09.用两个栈实现队列</title>
    <url>/2020/11/14/%E5%89%91%E6%8C%87%20Offer%EF%BC%9A09.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="剑指-Offer：09-用两个栈实现队列"><a href="#剑指-Offer：09-用两个栈实现队列" class="headerlink" title="剑指 Offer：09.用两个栈实现队列"></a>剑指 Offer：09.用两个栈实现队列</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>用两个栈实现一个队列。</p>
<h3 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">leetcode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>队列是先进后出，而栈是先进先出</li>
<li>用两个栈，一个用来入栈，一个用来出栈</li>
<li>对于一系列存在一个栈内的数据出栈再入栈，那么它们在栈内储存的顺序就会反过来，即可实现队列</li>
</ul>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1;</span><br><span class="line">    Stack&lt;Integer&gt; s2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        s2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s2.empty()&amp;&amp;s1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer：07.重建二叉树</title>
    <url>/2020/11/14/%E5%89%91%E6%8C%87%20Offer%EF%BC%9A07.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="剑指-Offer：07-重建二叉树"><a href="#剑指-Offer：07-重建二叉树" class="headerlink" title="剑指 Offer：07.重建二叉树"></a>剑指 Offer：07.重建二叉树</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">&gt;中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>返回如下的二叉树：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">leetcode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>首先理解什么是前序遍历和中序遍历：<ul>
<li>前序遍历：按照 根-&gt;左节点-&gt;右节点的顺序来遍历显示</li>
<li>中序遍历：按照 左节点-&gt;根-&gt;右节点的顺序来遍历显示</li>
</ul>
</li>
<li>前序遍历的首位一定是根结点，接着是这个根结点的左子树，然后是右子树</li>
<li>中序遍历的左部分为左子树，然后是根结点，接着是这个根结点的右子树</li>
<li>递归解决：<ul>
<li>用前序遍历找到根结点</li>
<li>在中序遍历中找到根结点，那么从根结点划分出两个子树，同时分出前序遍历的左右子树</li>
<li>重复该步骤，直到子树只有一个根结点</li>
</ul>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode father = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(inorder.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> father;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == preorder[<span class="number">0</span>])&#123;</span><br><span class="line"></span><br><span class="line">                father.left =  buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),</span><br><span class="line">                                         Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                father.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,</span><br><span class="line">                                                            preorder.length),</span><br><span class="line">                                         Arrays.copyOfRange(inorder,</span><br><span class="line">                                                            i+<span class="number">1</span>,inorder.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>可以新建一个类似的函数，改变传入的参数，直接使用原数组的空间，而不是子树遍历的拷贝</p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程</title>
    <url>/2020/11/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是软件工程？"><a href="#什么是软件工程？" class="headerlink" title="什么是软件工程？"></a>什么是软件工程？</h3><p>用来制造软件的工程化方法</p>
<h3 id="什么是软件？"><a href="#什么是软件？" class="headerlink" title="什么是软件？"></a>什么是软件？</h3><p>程序：是为实现特定目标或解决特定问题而用计算机语言编写的命令序列的集合</p>
<p>软件：软件是程序、数据以及开发、使用和维护所需要的所有文档的总称</p>
<p>软件 = 程序 + 数据 + 文档</p>
<h3 id="软件的本质特性："><a href="#软件的本质特性：" class="headerlink" title="软件的本质特性："></a>软件的本质特性：</h3><p>复杂度、一致性、可变（演化）性和不可见性</p>
<h3 id="软件开发面临的挑战"><a href="#软件开发面临的挑战" class="headerlink" title="软件开发面临的挑战"></a>软件开发面临的挑战</h3><ul>
<li>客户不满意</li>
<li>风险与成本问题</li>
<li>项目过程失控</li>
<li>无力管理团队</li>
</ul>
<h3 id="什么是工程化的方法？"><a href="#什么是工程化的方法？" class="headerlink" title="什么是工程化的方法？"></a>什么是工程化的方法？</h3><p>工程是将理论和所学的知识应用于实践的科学，以便经济有效地解决实际问题</p>
<h3 id="工程化思想"><a href="#工程化思想" class="headerlink" title="工程化思想"></a>工程化思想</h3><ul>
<li>分而治之</li>
<li>折中</li>
<li>复用</li>
</ul>
<h3 id="软件工程的内容"><a href="#软件工程的内容" class="headerlink" title="软件工程的内容"></a>软件工程的内容</h3><ul>
<li>工具</li>
<li>方法</li>
<li>过程</li>
<li>质量关注点</li>
</ul>
<h3 id="软件工程过程"><a href="#软件工程过程" class="headerlink" title="软件工程过程"></a>软件工程过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	A[问题定义]--&gt;B[需求开发]</span><br><span class="line">	B--&gt;C[软件设计]</span><br><span class="line">	C--&gt;D[软件实现]</span><br><span class="line">	D--&gt;E[软件测试]</span><br></pre></td></tr></table></figure>

<h2 id="软件项目开发过程与管理"><a href="#软件项目开发过程与管理" class="headerlink" title="软件项目开发过程与管理"></a>软件项目开发过程与管理</h2><h3 id="软件开发过程的典型阶段"><a href="#软件开发过程的典型阶段" class="headerlink" title="软件开发过程的典型阶段"></a>软件开发过程的典型阶段</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	A[计划]--&gt;B[需求分析]</span><br><span class="line">	B--&gt;C[软件设计]</span><br><span class="line">	C--&gt;D[软件实现]</span><br><span class="line">	D--&gt;E[软件验证]</span><br><span class="line">	E--&gt;F[软件维护]</span><br></pre></td></tr></table></figure>

<h3 id="典型软件过程模型"><a href="#典型软件过程模型" class="headerlink" title="典型软件过程模型"></a>典型软件过程模型</h3><ul>
<li>瀑布模型：线性，需要要求明确，上一阶段输出是下一阶段输入，难以修改</li>
<li>增量过程模型<ul>
<li>增量模型：本质是以迭代的方式运用瀑布模型</li>
<li>快速应用程序开发（RAD）：瀑布模型的高速变体，并行运行，侧重短周期</li>
</ul>
</li>
<li>演化过程模型<ul>
<li>快速原型开发模型：循环反复，不断调整，原型可抛弃</li>
<li>螺旋模型：将软件生存周期分为四个可重复的阶段：规划、风险分析、开发和评估</li>
</ul>
</li>
</ul>
<h3 id="软件管理的基本概念："><a href="#软件管理的基本概念：" class="headerlink" title="软件管理的基本概念："></a>软件管理的基本概念：</h3><ul>
<li>项目：进行定义的一组活动，使用受约束的资源来满足预定义的目标</li>
<li>项目管理：有效的组织和管理各类资源，以使项目能够在预定的范围、质量、时间和成本等约束条件下顺利交付</li>
</ul>
<h3 id="软件项目的特征"><a href="#软件项目的特征" class="headerlink" title="软件项目的特征"></a>软件项目的特征</h3><ul>
<li>软件产品的不可见性</li>
<li>项目的高度不确定性</li>
<li>软件过程的多变性</li>
<li>软件人员的高技能及其高流动性</li>
</ul>
<h3 id="项目估算的内容"><a href="#项目估算的内容" class="headerlink" title="项目估算的内容"></a>项目估算的内容</h3><ul>
<li>规模估算</li>
<li>工作量估算</li>
<li>进度估算</li>
<li>成本估算</li>
</ul>
<p>估算的风险取决于资源、成本及进度的定量估算中存在的不确定性</p>
<h3 id="代码行技术"><a href="#代码行技术" class="headerlink" title="代码行技术"></a>代码行技术</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksg344szpj30v00dejsz.jpg" alt="image-20201117203134488"></p>
<h2 id="软件需求工程"><a href="#软件需求工程" class="headerlink" title="软件需求工程"></a>软件需求工程</h2><h3 id="用户故事"><a href="#用户故事" class="headerlink" title="用户故事"></a>用户故事</h3><p>格式：作为一个&lt;角色&gt;，可以&lt;活动&gt;，以便于&lt;价值&gt;</p>
<h3 id="需求规格说明书（SRS）"><a href="#需求规格说明书（SRS）" class="headerlink" title="需求规格说明书（SRS）"></a>需求规格说明书（SRS）</h3><ul>
<li>功能</li>
<li>外部接口</li>
<li>性能</li>
<li>非功能属性</li>
<li>约束条件</li>
</ul>
<h3 id="SRS的三大部分"><a href="#SRS的三大部分" class="headerlink" title="SRS的三大部分"></a>SRS的三大部分</h3><ul>
<li>引言</li>
<li>整体描述</li>
<li>需求描述</li>
</ul>
<h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="软件工程方法"><a href="#软件工程方法" class="headerlink" title="软件工程方法"></a>软件工程方法</h3><ul>
<li>功能分解法</li>
<li>结构化方法</li>
<li>信息建模法</li>
<li>面向对象法</li>
</ul>
<h3 id="软件体系结构"><a href="#软件体系结构" class="headerlink" title="软件体系结构"></a>软件体系结构</h3><ul>
<li>构件</li>
<li>连接件</li>
<li>约束</li>
</ul>
<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>不考虑程序内部逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksiqhnruvj30o00d2jsb.jpg" alt="image-20201117220318785"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksjbm31o4j30ia0ckmyr.jpg" alt="image-20201117222337336"></p>
<h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksis3gc08j30hw0comyc.jpg" alt="image-20201117220451687"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksj0xkp6xj31ak0pmq8q.jpg" alt="image-20201117221320972"></p>
]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
</search>
