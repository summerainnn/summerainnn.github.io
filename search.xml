<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python实现爬取豆瓣电影评论</title>
    <url>/2020/11/10/python%E5%AE%9E%E7%8E%B0%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="python实现爬取豆瓣电影评论"><a href="#python实现爬取豆瓣电影评论" class="headerlink" title="python实现爬取豆瓣电影评论"></a>python实现爬取豆瓣电影评论</h1><h2 id="github"><a href="#github" class="headerlink" title="github"></a><a href="https://github.com/summerainnn/dbSpider">github</a></h2><h2 id="使用的库"><a href="#使用的库" class="headerlink" title="使用的库"></a>使用的库</h2><p>以前在写爬虫时使用的都是reques，这次发现了更好用的request_html，不需要再用bs4来解析网页了</p>
<blockquote>
<p>request_html</p>
</blockquote>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>首先建立一个会话（session），即让Python作为一个客户端，和远端服务器交谈</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">session = HTMLSession()</span><br></pre></td></tr></table></figure>

<p>然后就可以用session来进行get的操作，这里的URL可以自己在浏览器中寻找，找到你需要的数据的具体的get的网址，该网址并不一定是网页网址</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><a href="https://pypi.org/project/requests-html/">官方文档</a></h3><h3 id="如何用Python爬数据？（一）网页抓取"><a href="#如何用Python爬数据？（一）网页抓取" class="headerlink" title="如何用Python爬数据？（一）网页抓取"></a><a href="https://www.jianshu.com/p/ba02079ecd2f">如何用Python爬数据？（一）网页抓取</a></h3><h3 id="requests-html"><a href="#requests-html" class="headerlink" title="requests-html"></a><a href="https://www.jianshu.com/p/380974ba9540">requests-html</a></h3>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>应用</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode：26.删除排序数组中的重复项</title>
    <url>/2020/11/08/leetcode%EF%BC%9A26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26.删除排序数组中的重复项"></a>26.删除排序数组中的重复项</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">LeetCode</a></h3><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><ul>
<li>快慢两个指针，前一个用来计数，后一个用来遍历数组，在找到不同数字后进行交换</li>
<li>时间复杂度o（n），空间复杂度o（1）</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j];<span class="comment">//存在此时i==j的情况，可优化</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>重复</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>使用阿里云和hexo搭建个人博客</title>
    <url>/2020/12/02/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="使用阿里云和hexo搭建个人博客"><a href="#使用阿里云和hexo搭建个人博客" class="headerlink" title="使用阿里云和hexo搭建个人博客"></a>使用阿里云和hexo搭建个人博客</h1><p>本次主要参考的是<a href="https://blog.csdn.net/qq_37391214/article/details/106161526">阿里云服务器和 hexo 博客实战</a></p>
<p>现对其中遇到的问题进行总结</p>
<h2 id="1-nginx编译问题"><a href="#1-nginx编译问题" class="headerlink" title="1.nginx编译问题"></a>1.nginx编译问题</h2><p>原文提到的nginx版本有一点问题，无法通过编译，我选择了nginx-1.19.5这样一个版本</p>
<h2 id="2-双推送"><a href="#2-双推送" class="headerlink" title="2.双推送"></a>2.双推送</h2><p>因为域名是在阿里云购买的，必须绑定阿里云的服务器，此次迁移博客也是因为这个原因，但是还是希望推送到GitHub上，所以可以对_config.yml文件进行修改，使其可以推送到两个服务器上</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl9u32tm91j319e0aqwgb.jpg" alt="image-20201202213036808"></p>
<h2 id="3-nginx配置问题"><a href="#3-nginx配置问题" class="headerlink" title="3.nginx配置问题"></a>3.nginx配置问题</h2><p>nginx修改配置后需要再次重启nginx，才能使得配置生效</p>
]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>应用</tag>
        <tag>网站开发</tag>
        <tag>问题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode：21.合并两个有序链表</title>
    <url>/2020/11/08/Leetcode%EF%BC%9A21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">LeetCode</a></h3><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><ul>
<li>时间复杂度为o（m+n）</li>
<li>空间复杂度o（m+n）这是递归调用的深度，即最多调用m+n次</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><ul>
<li>时间复杂度o（m+n）</li>
<li>空间复杂度o（1），仅需要常数个node作为临时储存</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode answer = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode temp = answer;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                temp.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = l1==<span class="keyword">null</span>? l2:l1;</span><br><span class="line">        <span class="keyword">return</span> answer.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>合并</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能</title>
    <url>/2020/11/15/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
    <content><![CDATA[<h1 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h1><h2 id="什么是人工智能？"><a href="#什么是人工智能？" class="headerlink" title="什么是人工智能？"></a>什么是人工智能？</h2><ul>
<li>类人类思维方法：认知模型方法</li>
<li>类人行为方法：图灵测试</li>
<li>理性思维方法：思维法则</li>
<li>理性行为方法：理性智能体</li>
</ul>
<p>一般解释：用人工的方法在机器（计算机）上实现的智能</p>
<h2 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h2><h3 id="产生式表达法"><a href="#产生式表达法" class="headerlink" title="产生式表达法"></a>产生式表达法</h3><h4 id="事实的表示"><a href="#事实的表示" class="headerlink" title="事实的表示"></a>事实的表示</h4><h5 id="确定性知识表示"><a href="#确定性知识表示" class="headerlink" title="确定性知识表示"></a>确定性知识表示</h5><ul>
<li>（对象，属性，值） 例如：（雪，颜色，白）</li>
<li>（关系，对象1，对象2） 例如（热爱，汪峰，祖国）</li>
</ul>
<h5 id="非确定性知识："><a href="#非确定性知识：" class="headerlink" title="非确定性知识："></a>非确定性知识：</h5><ul>
<li>（对象，属性，值，可信度因子）</li>
</ul>
<h4 id="规则的表示"><a href="#规则的表示" class="headerlink" title="规则的表示"></a>规则的表示</h4><p>P -&gt; Q     IF P THEN Q</p>
<h3 id="语义网络表示法"><a href="#语义网络表示法" class="headerlink" title="语义网络表示法"></a>语义网络表示法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[节点1]--&gt;|语义关系|B[节点2] </span><br></pre></td></tr></table></figure>

<h4 id="基本语义关系"><a href="#基本语义关系" class="headerlink" title="基本语义关系"></a>基本语义关系</h4><ul>
<li>实例关系：ISA（是一个）</li>
<li>分类关系：AKO（是一种）</li>
<li>成员关系：A-Member-of（是一员）</li>
<li>聚类关系：Part-of（是一部分）</li>
<li>属性关系：<ul>
<li>Have（有） </li>
<li>Can（能，会）</li>
</ul>
</li>
<li>时间关系：<ul>
<li>Before（在前）</li>
<li>After（在后）</li>
</ul>
</li>
<li>位置关系：Locate-on（在···上面）</li>
<li>相近关系：Similar-to（相似）Near-to（接近）</li>
</ul>
<h3 id="框架表示法"><a href="#框架表示法" class="headerlink" title="框架表示法"></a>框架表示法</h3><h4 id="框架的结构："><a href="#框架的结构：" class="headerlink" title="框架的结构："></a>框架的结构：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Frame&lt;框架名&gt;</span><br><span class="line">槽名A：侧面名A1		值A11	值A12</span><br><span class="line">			侧面名A2		值A21  值A22</span><br><span class="line">槽名B：侧面名B1		值B11	值B12</span><br><span class="line">			侧面名A2		值B21  值B22</span><br></pre></td></tr></table></figure>

<h2 id="推理的分类"><a href="#推理的分类" class="headerlink" title="推理的分类"></a>推理的分类</h2><h4 id="演绎推理"><a href="#演绎推理" class="headerlink" title="演绎推理"></a>演绎推理</h4><p>常用形式：三段论</p>
<p>不能增值新知识</p>
<h4 id="归纳推理"><a href="#归纳推理" class="headerlink" title="归纳推理"></a>归纳推理</h4><p>从个别到一般的推理</p>
<p>可以增值新知识</p>
]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer：11.旋转数组的最小数字</title>
    <url>/2020/11/23/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a>剑指 Offer 11. 旋转数组的最小数字</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">LeetCode</a></h3><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><ul>
<li>一个有一定顺序的数组一般就考虑二分法来进行查找，使得时间复杂度降低到对数级别</li>
</ul>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[<span class="number">0</span>]&lt;numbers[numbers.length-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start != end)&#123;</span><br><span class="line">            mid = (start + end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start;numbers[mid]==numbers[start];i++)&#123;</span><br><span class="line">                mid = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(mid == numbers.length)&#123;</span><br><span class="line">                    mid = mid-<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid]&gt;numbers[start])&#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(start + <span class="number">1</span> == end)&#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[end];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="官方简洁版代码"><a href="#官方简洁版代码" class="headerlink" title="官方简洁版代码"></a>官方简洁版代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[pivot] &lt; numbers[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[pivot] &gt; numbers[high]) &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 13. 机器人的运动范围</title>
    <url>/2020/11/25/%E5%89%91%E6%8C%87%20Offer%2013.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<h1 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a>剑指 Offer 13. 机器人的运动范围</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">LeetCode</a></h3><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul>
<li>简单的dfs题目，用递归来实现即可</li>
<li>对于已到达的点需要进行标记，以便后续检查该点是否已到达</li>
</ul>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>对于简单的运算不要再写函数，否则反而因为调用函数而浪费了时间和空间</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] map = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,map,<span class="number">1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">boolean</span>[][] map, <span class="keyword">int</span> num,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==map.length||y==map[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((x/<span class="number">10</span>+x%<span class="number">10</span>+y/<span class="number">10</span>+y%<span class="number">10</span>)&lt;=k&amp;&amp; !map[x][y])&#123;</span><br><span class="line">                map[x][y] = <span class="keyword">true</span>;</span><br><span class="line">                num = dfs(x+<span class="number">1</span>,y,map,num,k) + dfs(x,y+<span class="number">1</span>,map,num,k) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>dfs</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 14- II. 剪绳子 II</title>
    <url>/2020/11/30/%E5%89%91%E6%8C%87%20Offer%2014-%20II.%20%E5%89%AA%E7%BB%B3%E5%AD%90%20II/</url>
    <content><![CDATA[<h1 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a>剑指 Offer 14- II. 剪绳子 II</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof">LeetCode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>首先找出规律，分成3相乘时，积最大，但是当剩余的长度为4时，分成2和2最大</li>
<li>需要定义long，使用int会有溢出的风险</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">4</span>)&#123;</span><br><span class="line">            sum = sum * <span class="number">3</span>;</span><br><span class="line">            sum = sum %<span class="number">1000000007</span>;</span><br><span class="line">            n = n - <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if(n==4)&#123;</span></span><br><span class="line">        <span class="comment">//     return sum*4%1000000007;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(n==3)&#123;</span></span><br><span class="line">        <span class="comment">//     return sum*3%1000000007;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(n == 2)&#123;</span></span><br><span class="line">        <span class="comment">//     return sum*2%1000000007;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (sum*n%<span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 15. 二进制中1的个数</title>
    <url>/2020/11/30/%E5%89%91%E6%8C%87%20Offer%2015.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a>剑指 Offer 15. 二进制中1的个数</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<p> 示例 1：</p>
<p>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<br>示例 2：</p>
<p>输入：00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。<br>示例 3：</p>
<p>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p>
<p>提示：</p>
<p>输入必须是长度为 32 的 二进制串 。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof">LeetCode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>使用移位的方法，来对每一位进行判断，是否为1</li>
<li>时间复杂度为O（$log_2N$）(此处的N并不是二进制的位数)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            res += n &amp; <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用n&amp;(n-1)的方法，对n进行减一的操作，再与原来的数进行与操作，可以使得该数的低位第一个1变成0</li>
<li>时间复杂度相比上一个方法有所降低</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 22. 链表中倒数第k个节点</title>
    <url>/2020/12/01/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p>示例：</p>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p>
<p>返回链表 4-&gt;5.</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">LeetCode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>链表中计数巧妙的使用双指针，让一个先行，另一个后续尾行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode start = head;</span><br><span class="line">        ListNode end = head;</span><br><span class="line">        <span class="keyword">for</span>(;k&gt;<span class="number">0</span>;k--)&#123;</span><br><span class="line">            end = end.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(end!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            start = start.next;</span><br><span class="line">            end = end.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 18. 删除链表的节点</title>
    <url>/2020/12/01/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。 </p>
<p>注意：此题对比原题有改动</p>
<p>示例 1:</p>
<p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p>
<p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof">LeetCode</a></h3><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul>
<li>对链表有基本的了解即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.val == val) &#123;</span><br><span class="line">            <span class="comment">//如果要删除的是头指针，直接令 head 指向下一个结点</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode n = head;</span><br><span class="line">        <span class="keyword">while</span>(n.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n.next.val == val)&#123;</span><br><span class="line">                n.next = n.next.next;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学</title>
    <url>/2020/12/13/%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>密码术：密码编码学+密码分析学</p>
<p>扩散：<strong>让明文中的每一位影响密文中的许多位，或者说让密文中的每一位受明文中的许多位的影响</strong>（明文<strong>统计特性散布</strong>到密文中）</p>
<p>混淆：<strong>将密文与密钥之间的统计关系变得尽可能复杂</strong></p>
<p>扩散和混淆的目的是为了抵抗对手对密码体制的统计分析（<strong>乘积和迭代有助于实现扩散和混淆</strong>）</p>
<p>对称加密：加密和解密由同一个密钥来控制，就是对称算法（单匙算法）</p>
<pre><code>- **加密** ：$E_K(M)=C$
- **解密** ：$D_K(C)=M$</code></pre>
<p>非对称加密：用作加密的密钥不同于用作解密的密钥，而且解密密钥不能根据加密密钥计算出来，就是非对称算法（公钥加密）</p>
<ul>
<li><strong>加密</strong> ：$E_{K1}(M)=C$</li>
<li><strong>解密</strong> ：$D_{K2}(C)=M$</li>
</ul>
<p>密码系统的攻击类型：</p>
<p><strong>（1）唯密文攻击</strong>：密码分析者仅知道一些密文。</p>
<p><strong>（2）已知明文攻击</strong>：密码分析者知道一些明文和相应的密文。</p>
<p><strong>（3）选择明文攻击</strong>：密码分析者可以选择一些明文，并得到相应的密文。</p>
<p><strong>（4）选择密文攻击</strong>：密码分析者可以选择一些密文，并得到相应的明文。</p>
<h3 id="分组密码工作模式"><a href="#分组密码工作模式" class="headerlink" title="分组密码工作模式:"></a>分组密码工作模式:</h3><p>电子密码本(Electronic Code Book, ECB)模式</p>
<p>​    Ø最简单的工作模式</p>
<p>​    Ø加密：一次对一个64比特长的明文分组加密，每次加密密钥相同</p>
<p>​    Ø适用于短消息加密传输</p>
<p>密码分组链接(Cipher Block Chaining, CBC)模式</p>
<p>​    Ø加密：一次对一个明文分组加密，每次加密使用同一密钥，加密算法的输入是当前明文分组和前一次密文分组的异或</p>
<p>密码反馈（Cipher Feedback，CFB）模式</p>
<p>​    <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmnqbyx7pj30h409l3za.jpg" alt="img"></p>
<p>输出反馈（Output Feedback, OFB）模式</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmnrckjgrj30hm0gowgd.jpg" alt="OFB加密和解密"></p>
<p>计数器模式(CTR, Counter Mode)</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmnrkxs5tj30fm0ch3zk.jpg" alt="img"></p>
<h2 id="数学基础知识"><a href="#数学基础知识" class="headerlink" title="数学基础知识"></a>数学基础知识</h2><p>扩展欧几里得算法：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmhub891mj30sw0jkwj1.jpg" alt="image-20201213201918360"></p>
<p>中国剩余定理：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmikbw9m8j31hc0kswnz.jpg" alt="image-20201213204421185"></p>
<p>费马小定理：</p>
<p>p为质数，a为任意自然数</p>
<p>$a^{p-1}\equiv1\ (mod\ p)$</p>
<p>密码算法四种性质：机密性、完整性、消息认证、不可否认</p>
<h2 id="密码算法"><a href="#密码算法" class="headerlink" title="密码算法"></a>密码算法</h2>]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理</title>
    <url>/2020/12/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>转载整合自<a href="https://www.bilibili.com/video/BV1ft4y1X7p6?p=3">编译原理—混子速成期末保过</a></p>
<h2 id="一、习题"><a href="#一、习题" class="headerlink" title="一、习题"></a>一、习题</h2><h3 id="1-集合"><a href="#1-集合" class="headerlink" title="1.集合"></a>1.集合</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glv8ro5i34j30ti0ckgng.jpg" alt="image-20201221095523996"></p>
<h3 id="2-文法"><a href="#2-文法" class="headerlink" title="2.文法"></a>2.文法</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glv8s4hlzdj31420aigmy.jpg" alt="image-20201219212804466"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glthninja4j318s0rye7u.jpg" alt="image-20201219213146516"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glthqe21i2j312g05en56.jpg" alt="image-20201219213431745"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gltif5j3k7j317g0b0dti.jpg" alt="image-20201219215819514"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glv8srstrwj30n808udh2.jpg" alt="image-20201219220301895"></p>
<h3 id="3-词法分析"><a href="#3-词法分析" class="headerlink" title="3.词法分析"></a>3.词法分析</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glti6ut0j1j30xq0acthn.jpg" alt="image-20201219215021767"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gltjb4h3jpj31by0i8qhu.jpg" alt="image-20201219222903897"></p>
<h3 id="4-语法分析"><a href="#4-语法分析" class="headerlink" title="4.语法分析 "></a>4.语法分析 <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glv8ssam0rj3108074q3v.jpg" alt="image-20201220100828634"></h3><h2 id="二、PPT重难点合集"><a href="#二、PPT重难点合集" class="headerlink" title="二、PPT重难点合集"></a>二、PPT重难点合集</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><ul>
<li>重点：<ul>
<li>编译系统的结构：<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu3x51inmj312y0u0q9k.jpg" alt="image-20201220102212223"></li>
</ul>
</li>
<li>难点：<ul>
<li>编译程序的生成<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glv8stqmlnj30ng09gt9e.jpg" alt="image-20201220103759973"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glv8st8z0cj30y20m6q66.jpg" alt="image-20201220103835776"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu4kg0oo3j31ag0cytaa.jpg" alt="image-20201220103903408"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu4kf9kzyj31ak0dq3zy.jpg" alt="image-20201220103932642"></li>
</ul>
</li>
</ul>
<h3 id="2-高级语言及其文法"><a href="#2-高级语言及其文法" class="headerlink" title="2.高级语言及其文法"></a>2.高级语言及其文法</h3><ul>
<li><p>重点：</p>
<ul>
<li><p>文法的定义与分类</p>
<ul>
<li><p>定义一个包含元素的集合为一个字母表∑</p>
</li>
<li><p>对字母表可进行乘和加。</p>
</li>
<li><p>$$<br>  ∑^+ = ∑^1+∑^2+∑^3+…\<br>  ∑^* = ∑^0+∑^1+∑^2+…\<br>  对任意的∑^0 = {ε}<br>  $$</p>
</li>
<li><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu4xyanwpj31420aigmy.jpg" alt="image-20201219212804466"></p>
</li>
<li><p>四种文法：<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu5596nrzj30xo0ikacg.jpg" alt="image-20201220110436053"></p>
</li>
<li><p>0型文法也称为短语文法:一个非常重要的理论结果是，0型文法的能力相当于图灵机（Turing）</p>
</li>
<li><p>1型文法（上下文有关文法）：A只有出现在α1α2的上下文中，才允许用β替换。</p>
</li>
<li><p>2型文法(CFG):即β取代A时，与A所处的上下文无关。（程序设计语言的多数语法</p>
</li>
<li><p>3型文法(RG)：也称正规文法</p>
<ul>
<li><p>每个产生式均为 “A→aB”或“A→a” —— 右线性</p>
<p>  　　 “A→Ba”或“A→a” —— 左线性</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CFG的语法树及二义性</p>
<ul>
<li>短语：语法树每一层的所有叶结点</li>
<li>直接短语：该子树不能再推出其它短语</li>
<li>句柄：最左边的直接短语</li>
<li>二义性：语法树唯一</li>
</ul>
</li>
</ul>
</li>
<li><p>难点：</p>
<ul>
<li>程序设计语言的语义定义</li>
</ul>
</li>
</ul>
<h3 id="3-词法分析-1"><a href="#3-词法分析-1" class="headerlink" title="3.词法分析"></a>3.词法分析</h3><ul>
<li>重点<ul>
<li>词法分析器的输入、输出<ul>
<li>输入源程序，输出单词符号(token)</li>
</ul>
</li>
<li>用于识别符号的状态转移图的构造<ul>
<li>有穷自动机<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glud8jamfwj314w0kadmc.jpg" alt="image-20201220154432277"></li>
</ul>
</li>
<li>根据状态转移图实现词法分析器</li>
</ul>
</li>
<li>难点<ul>
<li>词法的正规文法表示、正规表达式表示、状态转移图表示，它们之间的转换。 <ul>
<li><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu5zginv5j319q0hiacy.jpg" alt="image-20201219223422025"></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-自顶向下的语法分析"><a href="#4-自顶向下的语法分析" class="headerlink" title="4.自顶向下的语法分析"></a>4.自顶向下的语法分析</h3><ul>
<li>重点<ul>
<li>自顶向下分析的基本思想：<ul>
<li>递归子程序法（从根开始构建整棵树）</li>
<li>预测分析法(LL(1))</li>
</ul>
</li>
<li>预测分析器总体结构，预测分析表的构造，递归下降分析法基本思想，简单算术表达式的递归下降分析器。</li>
</ul>
</li>
<li>难点<ul>
<li>FIRST 和 FOLLOW 集的求法，<ul>
<li><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glufka7em5j30z70u04qp.jpg" alt="image-20201220170458995"></li>
</ul>
</li>
<li>对它们的理解以及在构造LL(1)分析表时的使用。递归子程序法中如何体现分析的结果。</li>
</ul>
</li>
</ul>
<h3 id="5-自底向上的语法分析"><a href="#5-自底向上的语法分析" class="headerlink" title="5.自底向上的语法分析"></a>5.自底向上的语法分析</h3><ul>
<li>重点<ul>
<li>自底向上分析的基本思想：从输入串出发，反复利用产生式进行归约，如果最后能得到文法的开始符号，则输入串是句子，否则输入串有语法错误。</li>
<li>算符优先分析法的基本思想，简单算符优先分析法。LR 分析器的基本构造思想，LR分析算法，规范句型活前缀及其识别器——DFA，LR(0)分析表的构造，SLR(1)分析表的构造, LR(1)分析表的构造。</li>
</ul>
</li>
<li>难点<ul>
<li>求FIRSTOP 和LASTOP，算符优先关系的确定，算符优先分析表的构造，素短语与最左素短语的概念。规范句型活前缀，LR(0)项目集闭包与项目集规范族，它们与句柄识别的关系，活前缀与句柄的关系, LR(1)项目集闭包与项目集规范族。 </li>
</ul>
</li>
</ul>
<h3 id="6-语法制导翻译与属性文法"><a href="#6-语法制导翻译与属性文法" class="headerlink" title="6.语法制导翻译与属性文法"></a>6.语法制导翻译与属性文法</h3><ul>
<li>重点<ul>
<li>语法制导翻译：语法分析中进行静态语义检查和中间代码生成的技术称为语法制导翻译技术</li>
<li>语法制导定义：为了通过将语义属性关联到文法符号、将语义规则关联到产生式，有效地将语法和语义关联起来，人们引入了语法制导定义，没有副作用的语法制导定义又称为属性文法</li>
<li>翻译模式：如果不仅将语义属性关联到文法符号、将语义规则关联到产生式，而且还通过将语义动作嵌入到产生式的适当位置来表达该语义动作的执行时机，这就是翻译模式。翻译模式给语义分析的实现提供了更好的支持。</li>
<li>自顶向下翻译，自底向上翻译。</li>
</ul>
</li>
<li>难点<ul>
<li>属性的意义：为相应的语法成分设置表示语义的属性，属性的值是可以计算的，根据属性值计算的关联关系，将其分成综合属性和继承属性，根据属性文法中所含的属性将属性文法分成<em>S</em>-属性文法和<em>L</em>-属性文法。</li>
<li>对综合属性，继承属性，固有属性的理解，属性计算，怎么通过属性来表达翻译。</li>
</ul>
</li>
</ul>
<h3 id="7-语义分析与中间代码生成"><a href="#7-语义分析与中间代码生成" class="headerlink" title="7.语义分析与中间代码生成"></a>7.语义分析与中间代码生成</h3><ul>
<li>重点<ul>
<li>三地址码：是指这种代码的每条指令最多只能包含三个地址，即两个操作数地址和一个结果地址。</li>
<li>各种语句的目标代码结构、语法制导定义与翻译模式。</li>
</ul>
</li>
<li>难点<ul>
<li>布尔表达式的翻译<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glumljhu9aj319e0mk784.jpg" alt="image-20201220210826008"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glv8sr0o6nj30jm0ouq4x.jpg" alt="image-20201220210803201"></li>
<li>对各种语句的目标代码结构、语法制导定义与翻译模式的理解。</li>
</ul>
</li>
</ul>
<h3 id="9-运行时的存储组织"><a href="#9-运行时的存储组织" class="headerlink" title="9.运行时的存储组织"></a>9.运行时的存储组织</h3><ul>
<li>重点<ul>
<li>符号表的内容、组织，过程调用实现，静态存储分配、动态存储分配的基本方法。</li>
</ul>
</li>
<li>难点<ul>
<li>参数传递，过程说明语句代码结构，过程调用语句的代码结构，过程调用语句的语法制导定义，栈式存储分配。 </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程</title>
    <url>/2020/11/17/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是软件工程？"><a href="#什么是软件工程？" class="headerlink" title="什么是软件工程？"></a>什么是软件工程？</h3><p>用来制造软件的工程化方法</p>
<h3 id="什么是软件？"><a href="#什么是软件？" class="headerlink" title="什么是软件？"></a>什么是软件？</h3><p>程序：是为实现特定目标或解决特定问题而用计算机语言编写的命令序列的集合</p>
<p>软件：软件是程序、数据以及开发、使用和维护所需要的所有文档的总称</p>
<p>软件 = 程序 + 数据 + 文档</p>
<h3 id="软件的本质特性："><a href="#软件的本质特性：" class="headerlink" title="软件的本质特性："></a>软件的本质特性：</h3><p>复杂度、一致性、可变（演化）性和不可见性</p>
<h3 id="软件开发面临的挑战"><a href="#软件开发面临的挑战" class="headerlink" title="软件开发面临的挑战"></a>软件开发面临的挑战</h3><ul>
<li>客户不满意</li>
<li>风险与成本问题</li>
<li>项目过程失控</li>
<li>无力管理团队</li>
</ul>
<h3 id="什么是工程化的方法？"><a href="#什么是工程化的方法？" class="headerlink" title="什么是工程化的方法？"></a>什么是工程化的方法？</h3><p>工程是将理论和所学的知识应用于实践的科学，以便经济有效地解决实际问题</p>
<h3 id="工程化思想"><a href="#工程化思想" class="headerlink" title="工程化思想"></a>工程化思想</h3><ul>
<li>分而治之</li>
<li>折中</li>
<li>复用</li>
</ul>
<h3 id="软件工程的内容"><a href="#软件工程的内容" class="headerlink" title="软件工程的内容"></a>软件工程的内容</h3><ul>
<li>工具</li>
<li>方法</li>
<li>过程</li>
<li>质量关注点</li>
</ul>
<h3 id="软件工程过程"><a href="#软件工程过程" class="headerlink" title="软件工程过程"></a>软件工程过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	A[问题定义]--&gt;B[需求开发]</span><br><span class="line">	B--&gt;C[软件设计]</span><br><span class="line">	C--&gt;D[软件实现]</span><br><span class="line">	D--&gt;E[软件测试]</span><br></pre></td></tr></table></figure>

<h2 id="软件项目开发过程与管理"><a href="#软件项目开发过程与管理" class="headerlink" title="软件项目开发过程与管理"></a>软件项目开发过程与管理</h2><h3 id="软件开发过程的典型阶段"><a href="#软件开发过程的典型阶段" class="headerlink" title="软件开发过程的典型阶段"></a>软件开发过程的典型阶段</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	A[计划]--&gt;B[需求分析]</span><br><span class="line">	B--&gt;C[软件设计]</span><br><span class="line">	C--&gt;D[软件实现]</span><br><span class="line">	D--&gt;E[软件验证]</span><br><span class="line">	E--&gt;F[软件维护]</span><br></pre></td></tr></table></figure>

<h3 id="典型软件过程模型"><a href="#典型软件过程模型" class="headerlink" title="典型软件过程模型"></a>典型软件过程模型</h3><ul>
<li>瀑布模型：线性，需要要求明确，上一阶段输出是下一阶段输入，难以修改</li>
<li>增量过程模型<ul>
<li>增量模型：本质是以迭代的方式运用瀑布模型</li>
<li>快速应用程序开发（RAD）：瀑布模型的高速变体，并行运行，侧重短周期</li>
</ul>
</li>
<li>演化过程模型<ul>
<li>快速原型开发模型：循环反复，不断调整，原型可抛弃</li>
<li>螺旋模型：将软件生存周期分为四个可重复的阶段：规划、风险分析、开发和评估</li>
</ul>
</li>
</ul>
<h3 id="软件管理的基本概念："><a href="#软件管理的基本概念：" class="headerlink" title="软件管理的基本概念："></a>软件管理的基本概念：</h3><ul>
<li>项目：进行定义的一组活动，使用受约束的资源来满足预定义的目标</li>
<li>项目管理：有效的组织和管理各类资源，以使项目能够在预定的范围、质量、时间和成本等约束条件下顺利交付</li>
</ul>
<h3 id="软件项目的特征"><a href="#软件项目的特征" class="headerlink" title="软件项目的特征"></a>软件项目的特征</h3><ul>
<li>软件产品的不可见性</li>
<li>项目的高度不确定性</li>
<li>软件过程的多变性</li>
<li>软件人员的高技能及其高流动性</li>
</ul>
<h3 id="项目估算的内容"><a href="#项目估算的内容" class="headerlink" title="项目估算的内容"></a>项目估算的内容</h3><ul>
<li>规模估算</li>
<li>工作量估算</li>
<li>进度估算</li>
<li>成本估算</li>
</ul>
<p>估算的风险取决于资源、成本及进度的定量估算中存在的不确定性</p>
<h3 id="代码行技术"><a href="#代码行技术" class="headerlink" title="代码行技术"></a>代码行技术</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksg344szpj30v00dejsz.jpg" alt="image-20201117203134488"></p>
<h2 id="软件需求工程"><a href="#软件需求工程" class="headerlink" title="软件需求工程"></a>软件需求工程</h2><h3 id="用户故事"><a href="#用户故事" class="headerlink" title="用户故事"></a>用户故事</h3><p>格式：作为一个&lt;角色&gt;，可以&lt;活动&gt;，以便于&lt;价值&gt;</p>
<h3 id="需求规格说明书（SRS）"><a href="#需求规格说明书（SRS）" class="headerlink" title="需求规格说明书（SRS）"></a>需求规格说明书（SRS）</h3><ul>
<li>功能</li>
<li>外部接口</li>
<li>性能</li>
<li>非功能属性</li>
<li>约束条件</li>
</ul>
<h3 id="SRS的三大部分"><a href="#SRS的三大部分" class="headerlink" title="SRS的三大部分"></a>SRS的三大部分</h3><ul>
<li>引言</li>
<li>整体描述</li>
<li>需求描述</li>
</ul>
<h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="软件工程方法"><a href="#软件工程方法" class="headerlink" title="软件工程方法"></a>软件工程方法</h3><ul>
<li>功能分解法</li>
<li>结构化方法</li>
<li>信息建模法</li>
<li>面向对象法</li>
</ul>
<h3 id="软件体系结构"><a href="#软件体系结构" class="headerlink" title="软件体系结构"></a>软件体系结构</h3><ul>
<li>构件</li>
<li>连接件</li>
<li>约束</li>
</ul>
<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>不考虑程序内部逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksiqhnruvj30o00d2jsb.jpg" alt="image-20201117220318785"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksjbm31o4j30ia0ckmyr.jpg" alt="image-20201117222337336"></p>
<h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksis3gc08j30hw0comyc.jpg" alt="image-20201117220451687"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gksj0xkp6xj31ak0pmq8q.jpg" alt="image-20201117221320972"></p>
]]></content>
      <categories>
        <category>复习总结</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 30. 包含min函数的栈</title>
    <url>/2020/12/26/%E5%89%91%E6%8C%87%20Offer%2030.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h1 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a>剑指 Offer 30. 包含min函数的栈</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">LeetCode</a></h2><hr>
<h2 id="前置知识点回顾："><a href="#前置知识点回顾：" class="headerlink" title="前置知识点回顾："></a>前置知识点回顾：</h2><p>java栈的相关函数及用法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">boolean empty()  测试堆栈是否为空。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Object push(Object element) 把项压入堆栈顶部。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。</td>
</tr>
</tbody></table>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="1-两个栈来解决"><a href="#1-两个栈来解决" class="headerlink" title="1.两个栈来解决"></a>1.两个栈来解决</h3><ul>
<li>维护两个栈，一个为正常栈，另一个为压栈时出现过的最小值，栈顶为当前最小值</li>
<li>出栈时检测出栈元素是否为当前栈最小值，若为最小值，则将存有最小值的栈出栈</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; A,B;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> Stack&lt;&gt;();   </span><br><span class="line">        B = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B.empty()||B.peek()&gt;=x)&#123;</span><br><span class="line">            B.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        A.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.pop().equals(B.peek()))&#123;</span><br><span class="line">            B.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="2-一个栈解决"><a href="#2-一个栈解决" class="headerlink" title="2.一个栈解决"></a>2.一个栈解决</h3><ul>
<li>仅使用一个空间来表示当前栈最小值</li>
<li>入栈时检测最小值是否发生变化，如果变化则将原来的最小值先入栈，若不变化，则正常入栈</li>
<li>出栈时正常出栈，接着检测出栈元素是否为当前最小值，如果是，则再次出栈，将该元素更改为当前栈最小值</li>
</ul>
<h4 id="注意：在A为空时，压入的值即为最小值"><a href="#注意：在A为空时，压入的值即为最小值" class="headerlink" title="注意：在A为空时，压入的值即为最小值"></a>注意：在A为空时，压入的值即为最小值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; A ;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=min||A.empty())&#123;</span><br><span class="line">            A.add(min);</span><br><span class="line">            A.add(x);</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            A.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.pop().equals(min))&#123;</span><br><span class="line">            min = A.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 32 - II. 从上到下打印二叉树 II</title>
    <url>/2020/12/28/%E5%89%91%E6%8C%87%20Offer%2032%20-%20II.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20II/</url>
    <content><![CDATA[<h1 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a>剑指 Offer 32 - II. 从上到下打印二叉树 II</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">LeetCode</a></h2><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>利用广度优先的思想来进行解题</li>
</ul>
<h3 id="注意：需要首先用i来记录下queue的size，因为该大小是变化的"><a href="#注意：需要首先用i来记录下queue的size，因为该大小是变化的" class="headerlink" title="注意：需要首先用i来记录下queue的size，因为该大小是变化的"></a>注意：需要首先用i来记录下queue的size，因为该大小是变化的</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=queue.size();i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                TreeNode node  = queue.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            answer.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 39. 数组中出现次数超过一半的数字</title>
    <url>/2020/12/28/%E5%89%91%E6%8C%87%20Offer%2039.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a>剑指 Offer 39. 数组中出现次数超过一半的数字</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">LeetCode</a></h2><hr>
<h2 id="前置知识点回顾："><a href="#前置知识点回顾：" class="headerlink" title="前置知识点回顾："></a>前置知识点回顾：</h2><p>java中HasMap的相关函数及用法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-clear.html">clear()</a></td>
<td align="left">删除 hashMap 中的所有键/值对</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-clone.html">clone()</a></td>
<td align="left">复制一份 hashMap</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-isempty.html">isEmpty()</a></td>
<td align="left">判断 hashMap 是否为空</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-size.html">size()</a></td>
<td align="left">计算 hashMap 中键/值对的数量</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-put.html">put()</a></td>
<td align="left">将键/值对添加到 hashMap 中</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-putall.html">putAll()</a></td>
<td align="left">将所有键/值对添加到 hashMap 中</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-putifabsent.html">putIfAbsent()</a></td>
<td align="left">如果 hashMap 中不存在指定的键，则将指定的键/值对插入到 hashMap 中。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-remove.html">remove()</a></td>
<td align="left">删除 hashMap 中指定键 key 的映射关系</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-containskey.html">containsKey()</a></td>
<td align="left">检查 hashMap 中是否存在指定的 key 对应的映射关系。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-containsvalue.html">containsValue()</a></td>
<td align="left">检查 hashMap 中是否存在指定的 value 对应的映射关系。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-replace.html">replace()</a></td>
<td align="left">替换 hashMap 中是指定的 key 对应的 value。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-replaceall.html">replaceAll()</a></td>
<td align="left">将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-get.html">get()</a></td>
<td align="left">获取指定 key 对应对 value</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-getordefault.html">getOrDefault()</a></td>
<td align="left">获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-foreach.html">forEach()</a></td>
<td align="left">对 hashMap 中的每个映射执行指定的操作。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-entryset.html">entrySet()</a></td>
<td align="left">返回 hashMap 中所有映射项的集合集合视图。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-keyset.html">keySet</a>()</td>
<td align="left">返回 hashMap 中所有 key 组成的集合视图。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-values.html">values()</a></td>
<td align="left">返回 hashMap 中存在的所有 value 值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-merge.html">merge()</a></td>
<td align="left">添加键值对到 hashMap 中</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-compute.html">compute()</a></td>
<td align="left">对 hashMap 中指定 key 的值进行重新计算</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-computeifabsent.html">computeIfAbsent()</a></td>
<td align="left">对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hasMap 中</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/java/java-hashmap-computeifpresent.html">computeIfPresent()</a></td>
<td align="left">对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。</td>
</tr>
</tbody></table>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li><p>使用HashMap来对数组进行遍历并记录每个数字出现的个数，对每个数都判断其是否超过了一半，若超过，则返回答案</p>
<ul>
<li><p>时间复杂度和空间复杂度都是o（n）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.get(num) &gt; n) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>最佳解法：摩尔投票</p>
<ul>
<li><p>空间复杂度为o（1）</p>
</li>
<li><p>具体思路为遍历数组，对两个不同的元素进行消去操作，最后剩下的元素即为出现次数超过一半的数</p>
</li>
<li><p>具体实现时使用的技巧为“投票”，将数组的第一个值记为众数，在遍历数组遇到相同值则计数器加1，否则计数器减一，计数器为0则代表前面的数值被全部消去，将下一个值再次记为众数，重复该过程，最后得到的即为众数</p>
</li>
<li><p>需要注意的是该数组中必须存在超过半数的众数，否则无法找到众数</p>
</li>
<li><p>可以通过多遍历一次的方法来进行验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> answer=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                answer = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(answer == num)&#123;</span><br><span class="line">                count = count + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count = count - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(answer==num)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; n)&#123;</span><br><span class="line">                <span class="keyword">return</span> answer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 无答案</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java（2）多态</title>
    <url>/2020/11/26/Java%EF%BC%882%EF%BC%89%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（1）概念和定义</title>
    <url>/2020/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<h1 id="操作系统的概念和定义"><a href="#操作系统的概念和定义" class="headerlink" title="操作系统的概念和定义"></a>操作系统的概念和定义</h1><h2 id="一、操作系统的功能和目标："><a href="#一、操作系统的功能和目标：" class="headerlink" title="一、操作系统的功能和目标："></a>一、操作系统的功能和目标：</h2><h3 id="1-作为系统资源的管理者"><a href="#1-作为系统资源的管理者" class="headerlink" title="1.作为系统资源的管理者"></a>1.作为系统资源的管理者</h3><ul>
<li>提供的功能<ul>
<li>处理机管理</li>
<li>储存器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
</li>
<li>目标： 安全、高效</li>
</ul>
<h3 id="2-作为用户和计算机硬件之间的接口"><a href="#2-作为用户和计算机硬件之间的接口" class="headerlink" title="2.作为用户和计算机硬件之间的接口"></a>2.作为用户和计算机硬件之间的接口</h3><ul>
<li>提供的功能<ul>
<li>命令接口<ul>
<li>联机命令接口：交互式命令接口（实时反馈）</li>
<li>脱机命令接口：批处理命令接口（系列指令执行）</li>
</ul>
</li>
<li>程序接口：系统调用（广义指令）</li>
<li>CUI（图形用户界面）</li>
</ul>
</li>
<li>目标：方便用户使用</li>
</ul>
<h3 id="3-实现对硬件机器的拓展"><a href="#3-实现对硬件机器的拓展" class="headerlink" title="3.实现对硬件机器的拓展"></a>3.实现对硬件机器的拓展</h3><h2 id="二、操作系统的特征"><a href="#二、操作系统的特征" class="headerlink" title="二、操作系统的特征"></a>二、操作系统的特征</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1.并发"></a>1.并发</h3><p>微观上交替，宏观上同时</p>
<h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2.共享"></a>2.共享</h3><ul>
<li>互斥共享：一个时间段只允许一个进程访问该资源</li>
<li>同时共享：允许一个时间段内多个进程“同时”对它们访问（宏观上同时）</li>
</ul>
<h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3.虚拟"></a>3.虚拟</h3><p>把一个物理上的实体变为若干个逻辑上的对应物物理实体是实际存在的，而逻辑对应物是用户感受到的</p>
<ul>
<li>空分复用技术（虚拟储存技术）</li>
<li>时分复用技术（虚拟处理器）</li>
</ul>
<h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4.异步"></a>4.异步</h3><p>允许多个程序并发执行，由于资源有限，进程执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java（1）接口</title>
    <url>/2020/11/26/Java%EF%BC%881%EF%BC%89%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="Java（一）接口"><a href="#Java（一）接口" class="headerlink" title="Java（一）接口"></a>Java（一）接口</h1><h2 id="1-定义格式"><a href="#1-定义格式" class="headerlink" title="1.定义格式"></a>1.定义格式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;</span><br><span class="line">	<span class="comment">// 接口内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-使用步骤"><a href="#2-使用步骤" class="headerlink" title="2.使用步骤"></a>2.使用步骤</h2><ol>
<li><p>接口不能直接使用，必须有一个“实现类”来“实现”该接口</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 实现类名称 <span class="keyword">implements</span> 接口名称</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口的实现类必须覆盖重写（实现）接口中的所有抽象方法</p>
<p> 实现：去掉abstract关键字，加上方法体大括号</p>
</li>
<li><p>创建实现类的对象，进行使用</p>
</li>
</ol>
<h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h2><p>如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类</p>
<h2 id="4-具体例子"><a href="#4-具体例子" class="headerlink" title="4.具体例子"></a>4.具体例子</h2><ol>
<li><p>MyInterfaceAbstract</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceAbstract</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接口中也可以定义“成员变量”，但是必须用public static final三个关键字进行修饰</span></span><br><span class="line">    <span class="comment">// 从效果上看，这就是接口的【常量】</span></span><br><span class="line">    <span class="comment">// 可以省略public static final三个关键字不写，但效果是等同的</span></span><br><span class="line">    <span class="comment">// 该常量必须手动赋值，且不可改变</span></span><br><span class="line">    <span class="comment">// 推荐命名规则，全大写，使用下划线分隔单词</span></span><br><span class="line">    <span class="comment">// 访问时直接用接口名称调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_OF = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// public abstract可以省略，默认为抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新添加一个默认方法，可用于接口升级，使之前实现的类不需要重写该方法，也能继续使用</span></span><br><span class="line">    <span class="comment">// 该默认方法可以在实现类中直接调用，也可以进行覆盖重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接口中也可以定义静态方法，通过接口名称直接调用静态方法，即可使用</span></span><br><span class="line">    <span class="comment">// 注意事项：不能通过接口实现类来调用接口中的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接口中可以定义私有方法，使得该方法不会被实现类访问,但可以被接口中的默认方法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodCommon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接口中可以定义静态私有方法，使得该方法不会被实现类访问,但可以被接口中的静态方法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStaticCommon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MyInterfaceAbstractImpl</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceAbstractImpl</span> <span class="keyword">implements</span> <span class="title">MyInterfaceAbstract</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="5-接口的实现类"><a href="#5-接口的实现类" class="headerlink" title="5.接口的实现类"></a>5.接口的实现类</h2><p>一个类可以实现多个接口，但所有接口中的抽象方法都要重写</p>
<p>如果实现多个接口中存在重复的抽象方法，只需要覆盖重写一次即可</p>
<p>如果实现多个接口中存在重复的默认方法，需要覆盖重写</p>
<p>如果类的父类方法和接口中的默认方法产生冲突，优先使用父类方法</p>
<p>接口是可以多继承接口的，父接口的默认方法冲突需要重写，抽象方法冲突无影响</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（3）系统调用</title>
    <url>/2020/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%883%EF%BC%89%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="一、系统调用的意义"><a href="#一、系统调用的意义" class="headerlink" title="一、系统调用的意义"></a>一、系统调用的意义</h2><p>操作系统提供给应用程序使用的接口，来获得操作系统的服务</p>
<p>系统调用使得系统中的各种资源由操作系统统一掌控</p>
<h2 id="二、系统调用和库函数的区别"><a href="#二、系统调用和库函数的区别" class="headerlink" title="二、系统调用和库函数的区别"></a>二、系统调用和库函数的区别</h2><p>库函数封装了系统调用</p>
<h2 id="三、系统调用的过程"><a href="#三、系统调用的过程" class="headerlink" title="三、系统调用的过程"></a>三、系统调用的过程</h2><ol>
<li>传递系统调用参数</li>
<li>执行陷入指令（只能在用户态执行的指令，不能在和心态执行）</li>
<li>执行系统调用相应服务程序</li>
<li>返回用户程序</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（2）中断和异常</title>
    <url>/2020/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><h2 id="一、中断的意义"><a href="#一、中断的意义" class="headerlink" title="一、中断的意义"></a>一、中断的意义</h2><p>实现多道程序并发执行</p>
<p>本质：发生中断，意味着需要操作系统介入，开展管理工作（中断是唯一途径使得用户态-&gt;核心态）</p>
<h2 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h2><ul>
<li>中断发生时，CPU立即进入核心态</li>
<li>中断发生后，当前进程暂停运行，并由操作系统内核对中断进行处理</li>
<li>对不同的中断信号，会进行不同的处理</li>
</ul>
<h2 id="三、分类"><a href="#三、分类" class="headerlink" title="三、分类"></a>三、分类</h2><ul>
<li>内中断（异常）：信号来自CPU内部，与当前执行的指令有关<ul>
<li>自愿中断（指令中断）</li>
<li>强迫中断<ul>
<li>硬件故障</li>
<li>软件中断</li>
</ul>
</li>
</ul>
</li>
<li>外中断（中继）：信号来自CPU外部，与当前执行的指令无关<ul>
<li>外设请求</li>
<li>人工干预</li>
</ul>
</li>
</ul>
<h2 id="四、外中断的处理过程"><a href="#四、外中断的处理过程" class="headerlink" title="四、外中断的处理过程"></a>四、外中断的处理过程</h2><ol>
<li>执行完每个指令后都要检查是否有外部中断信号</li>
<li>如果检测到外部中断信号，则需要保护被中断进程的CPU环境</li>
<li>根据中断信号转入相应的中断处理程序</li>
<li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（5）调度算法</title>
    <url>/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%885%EF%BC%89%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="1-FCFS（First-Come-First-Serve）"><a href="#1-FCFS（First-Come-First-Serve）" class="headerlink" title="1.FCFS（First Come First Serve）"></a>1.FCFS（First Come First Serve）</h2><p>先到先服务，非抢占式</p>
<ul>
<li>优点：算法简单易实现，公平</li>
<li>缺点：对长作业有利，对短作业不利</li>
</ul>
<h2 id="2-SJF（Shortest-Job-First）"><a href="#2-SJF（Shortest-Job-First）" class="headerlink" title="2.SJF（Shortest Job First）"></a>2.SJF（Shortest Job First）</h2><p>短进程先进性，分为抢占式和非抢占式</p>
<ul>
<li>最短的平均等待时间，平均周转时间</li>
<li>对短作业有利，长作业不利，可能产生饥饿</li>
</ul>
<h2 id="3-HRRN（Highest-Response-Ration-Next"><a href="#3-HRRN（Highest-Response-Ration-Next" class="headerlink" title="3.HRRN（Highest Response Ration Next)"></a>3.HRRN（Highest Response Ration Next)</h2><p>每次调度时计算响应比（$\frac{等待时间+要求服务时间}{要求服务时间}$），选择响应比最高的进行服务，一般为非抢占式</p>
<h2 id="4-时间片轮转（RR，Round-Robin）"><a href="#4-时间片轮转（RR，Round-Robin）" class="headerlink" title="4.时间片轮转（RR，Round-Robin）"></a>4.时间片轮转（RR，Round-Robin）</h2><p>公平的轮流为各个进程服务，抢占式</p>
<ul>
<li>优点：公平，适用于分时操作系统</li>
<li>缺点：进程切换导致有一定开销，且不区分紧急程度</li>
</ul>
<h2 id="5-优先级调服算法"><a href="#5-优先级调服算法" class="headerlink" title="5.优先级调服算法"></a>5.优先级调服算法</h2><p>调度时选择最高优先级的活动，非抢占式和抢占式</p>
<ul>
<li>优点：适用于实时操作系统</li>
<li>缺点：可能导致饥饿</li>
</ul>
<h2 id="6-多级反馈队列调度算法"><a href="#6-多级反馈队列调度算法" class="headerlink" title="6.多级反馈队列调度算法"></a>6.多级反馈队列调度算法</h2>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（4）进程</title>
    <url>/2020/11/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%884%EF%BC%89%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="一、进程的定义"><a href="#一、进程的定义" class="headerlink" title="一、进程的定义"></a>一、进程的定义</h2><p>程序段、数据段、PCB三部分组成了进程实体，PCB是进程存在的唯一标志，用来描述进程的各种信息。</p>
<h3 id="典型定义："><a href="#典型定义：" class="headerlink" title="典型定义："></a>典型定义：</h3><p>进程是程序的一次执行过程</p>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p>
<h2 id="二、进程的组成"><a href="#二、进程的组成" class="headerlink" title="二、进程的组成"></a>二、进程的组成</h2><ul>
<li><h3 id="PCB："><a href="#PCB：" class="headerlink" title="PCB："></a>PCB：</h3><ul>
<li>进程描述信息：进程标识符PID、用户标识符UID</li>
<li>进程控制和管理信息：进程当前状态、进程优先级</li>
<li>资源分配清单：程序段指针、数据段指针、键盘、鼠标</li>
<li>处理机相关信息：各种寄存器值</li>
</ul>
</li>
<li><h3 id="程序段："><a href="#程序段：" class="headerlink" title="程序段："></a>程序段：</h3><ul>
<li>存放要执行的代码</li>
</ul>
</li>
<li><h3 id="数据段："><a href="#数据段：" class="headerlink" title="数据段："></a>数据段：</h3><ul>
<li>存放程序运行过程中处理的各种数据</li>
</ul>
</li>
</ul>
<h2 id="三、进程的组织"><a href="#三、进程的组织" class="headerlink" title="三、进程的组织"></a>三、进程的组织</h2><p>多个进程之间的组织方式问题</p>
<ul>
<li><h3 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h3><ul>
<li>按照进程状态将PCB分为多个队列<ul>
<li>执行指针-&gt;当前处于运行态的进程（单CPU中，只有一个进程在同一时刻运行）</li>
<li>就绪队列指针-&gt;处于就绪态的进程（为一个队列，优先级高的在前）</li>
<li>阻塞队列指针-&gt;处于阻塞态的进程（可能有多个阻塞队列）</li>
</ul>
</li>
<li>操作系统持有指向各个队列的指针</li>
</ul>
</li>
<li><h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><ul>
<li>根据进程状态的不同，建立几张索引表</li>
<li>操作系统持有指向各个索引表的指针</li>
</ul>
</li>
</ul>
<h2 id="四、进程的特征"><a href="#四、进程的特征" class="headerlink" title="四、进程的特征"></a>四、进程的特征</h2><ol>
<li>动态性：进程是动态的、变化的、消亡的</li>
<li>并发性：内存中有多个进程实体，各进程可并发执行</li>
<li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li>异步性：并发执行的进程的结果的完成速度的不确定性，操作系统需要提供“进程同步机制”来解决异步问题</li>
<li>结构性：每个进程都配备一个PCB，结构上由数据段、代码段、PCB组成</li>
</ol>
<h2 id="五、进程的状态"><a href="#五、进程的状态" class="headerlink" title="五、进程的状态"></a>五、进程的状态</h2><h3 id="1-三种基本状态："><a href="#1-三种基本状态：" class="headerlink" title="1. 三种基本状态："></a>1. 三种基本状态：</h3><ul>
<li>运行态：占用CPU<ul>
<li>CPU✅其它所需资源✅</li>
</ul>
</li>
<li>就绪态：可以运行，但CPU被其它进程占用<ul>
<li>CPU❌其它所需资源✅</li>
</ul>
</li>
<li>阻塞态：等待某一事件的完成而暂时无法运行<ul>
<li>CPU❌其它所需资源❌</li>
</ul>
</li>
</ul>
<h3 id="2-另外两种状态："><a href="#2-另外两种状态：" class="headerlink" title="2.另外两种状态："></a>2.另外两种状态：</h3><ul>
<li>创建态：操作系统为进程分配资源、初始化PCB</li>
<li>终止态：进程从操作系统中撤销，操作系统回收进程资源，撤销PCB</li>
</ul>
<h3 id="3-进程的状态转换"><a href="#3-进程的状态转换" class="headerlink" title="3.进程的状态转换"></a>3.进程的状态转换</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl2d2mq7nvj31go0nugqd.jpg" alt="image-20201126102303056"></p>
<p>注意：运行态-&gt;阻塞态是进程自身的主动行为</p>
<p>​           阻塞态-&gt;就绪态是被动的，阻塞态不能直接转换为运行态</p>
<h2 id="六、进程控制"><a href="#六、进程控制" class="headerlink" title="六、进程控制"></a>六、进程控制</h2><h3 id="1-实现的方式："><a href="#1-实现的方式：" class="headerlink" title="1.实现的方式："></a>1.实现的方式：</h3><p>用原语来实现进程的控制，其特点是执行期间不允许中断（原子操作），可以保证进程转换时PCB不会发生混乱（保证进程转换的过程完整发生，而不被其它中断打断，原语运行在核心态中，采用“关中断指令”和“开中断指令”，权限极大是核心态下执行的特权指令）</p>
<h3 id="2-控制的内容："><a href="#2-控制的内容：" class="headerlink" title="2.控制的内容："></a>2.控制的内容：</h3><ul>
<li>更新PCB中的信息</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ul>
<h2 id="七、进程通信"><a href="#七、进程通信" class="headerlink" title="七、进程通信"></a>七、进程通信</h2><p>进程间的信息交换</p>
<h3 id="1-共享存储"><a href="#1-共享存储" class="headerlink" title="1. 共享存储"></a>1. 共享存储</h3><p>两个进程对共享空间的访问必须是<strong>互斥</strong>的（操作系统只负责提供共享空间和同步互斥工具）</p>
<ul>
<li>基于数据结构的共享<ul>
<li>速度慢、限制多，是一种低级通信方式</li>
</ul>
</li>
<li>基于储存区的共享<ul>
<li>数据的形式和存放位置都由进程控制，速度更快，是一种高级通信方式</li>
</ul>
</li>
</ul>
<h3 id="2-管道通信"><a href="#2-管道通信" class="headerlink" title="2.管道通信"></a>2.管道通信</h3><p>在内存中开辟一个大小固定的缓存区</p>
<ul>
<li>管道只能采用<strong>半双工</strong>通信，某一时间段只能实现单向的传输，要实现双向同时通信，需要两个管道</li>
<li>各进程<strong>互斥</strong>地形式访问管道</li>
<li>数据以字符流的形式写入管道，当管道写满时，写进程的write()将被阻塞，等待读进程。当读进程将数据全部取走后，管道变空，此时读进程的read()将被阻塞</li>
<li>如果<strong>没写满，就不允许读</strong>，如果<strong>没读空，就不允许写</strong></li>
<li>数据一旦被读出，就从管道中被抛弃，这就意味着读<strong>进程最多只能有一个</strong>，否则可能会有读错数据的情况。</li>
</ul>
<h3 id="3-消息传递"><a href="#3-消息传递" class="headerlink" title="3.消息传递"></a>3.消息传递</h3><p>进程间的数据交换以<strong>格式化的消息</strong>为单位。通过操作系统提供的“发消息/接受消息”两个<strong>原语</strong>进行数据交换</p>
<p>消息由<strong>消息头</strong>和<strong>消息体</strong>组成：消息头包括发送进程ID、接受进程ID、消息类型、消息长度等格式化信息（计网中的“报文”就是一种<strong>格式化</strong>的消息）</p>
<ul>
<li>直接通信方式：消息直接挂到接收进程的消息缓冲队列上</li>
<li>间接通信方式：消息先发送到中间实体（信箱）中，也称信箱通信方式</li>
</ul>
<h2 id="八、进程互斥"><a href="#八、进程互斥" class="headerlink" title="八、进程互斥"></a>八、进程互斥</h2><p>实现对临界资源的互斥访问</p>
<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
<p>软件实现方法：</p>
<ul>
<li>单标志法</li>
<li>双标志先检查</li>
<li>双标志后检查</li>
<li>Peterson算法</li>
</ul>
<h3 id="Peterson算法："><a href="#Peterson算法：" class="headerlink" title="Peterson算法："></a>Peterson算法：</h3><p>结合双标志后检查法和单标志法，定义一个布尔数组和一个轮转标志，同时检查这两个标志，优先让对方先使用临界资源</p>
<hr>
<p>硬件实现方法：</p>
<ul>
<li>中断屏蔽法</li>
<li>TestAndSet</li>
<li>Swap指令</li>
</ul>
<h3 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">bool</span> *lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>; <span class="comment">// 上锁</span></span><br><span class="line">    <span class="keyword">return</span> old; <span class="comment">// 返回上锁前的状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TSL指令实现</span></span><br><span class="line"><span class="keyword">while</span>(TestAndSet(&amp;lock));<span class="comment">// 不停上锁，直到发现某一次临界资源并未被上锁</span></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line">lock = <span class="literal">false</span>; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<h3 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h3><p>交换old和lock的值来实现锁</p>
<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p>用户通过操作系统提供的原语来对信号量进行操作，从而实现进程互斥和同步</p>
<p>一对原语：wait和signal，简写为P、V操作，P（wait，代表需要别人等等，自己要使用了，所以减一）就是将信号量减一，V（signal）就是将信号量加一</p>
<h3 id="整型信号量："><a href="#整型信号量：" class="headerlink" title="整型信号量："></a>整型信号量：</h3><p>用来表示系统中某种资源的数量（只能进行初始化、P操作和V操作）</p>
<h3 id="记录型信号量："><a href="#记录型信号量：" class="headerlink" title="记录型信号量："></a>记录型信号量：</h3><p>整型存在忙等问题，用记录型数据结构表示信号量。可以阻塞进程（让权等待，不会忙等），同时用负数表示资源数，记录有进程在等待资源，维护一个等待队列，记录阻塞进程。</p>
<h3 id="实现进程互斥："><a href="#实现进程互斥：" class="headerlink" title="实现进程互斥："></a>实现进程互斥：</h3><p>设置互斥信号量mutex = 1</p>
<p>进临界区前执行P（mutex）</p>
<p>出临界区后执行V（mutex）</p>
<h3 id="实现进程同步："><a href="#实现进程同步：" class="headerlink" title="实现进程同步："></a>实现进程同步：</h3><p>进程同步问题：让本来异步并发的进程互相配合，有序推进</p>
<p>设置同步信号量S = 0</p>
<p>在“前操作”之后执行V（S）：执行了加一，相当于有资源了，后续的代码即可执行</p>
<p>在“后操作”之前执行P（S）：只有当S执行了加一，才能执行后续的操作，即前操作必须先执行完才可执行后操作</p>
<h4 id="拓展：实现前驱关系"><a href="#拓展：实现前驱关系" class="headerlink" title="拓展：实现前驱关系"></a>拓展：实现前驱关系</h4><p>对于多个代码的前驱关系，需要多个信号量即可</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（6）具体问题</title>
    <url>/2020/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%886%EF%BC%89%E5%85%B7%E4%BD%93%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>有一个进程可以生产一种资源（生产者程序），另一种程序需要消耗这种资源才能执行，使用一个有限的缓存区来保存这种资源</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>生产者和消费者对于缓存区的使用必须是互斥的，而且针对缓存区满和空这两种情况，生产者和消费者之间有两种先后执行的顺序，即两种同步关系（考虑资源为0时必须先执行生产者，资源为满时必须先执行消费者）</p>
<h2 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaohore mutex &#x3D; 1</span><br><span class="line">semaohore empty &#x3D; n</span><br><span class="line">semaohore full &#x3D; 0</span><br><span class="line">producer()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		生产一个产品；</span><br><span class="line">		P(empty);</span><br><span class="line">		P(mutex);</span><br><span class="line">		把产品放入缓存区；</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(full)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(full);</span><br><span class="line">		P(mutex);</span><br><span class="line">		从缓存区取出一个产品；</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(empty);</span><br><span class="line">		使用产品；</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>实现互斥的P操作一定要在实现同步的P操作之后，否则可能导致死锁（考虑缓存区为双方必须的，但是当一个进程占用后，缓存区确没有自己想要的资源，必须要对方提供，但是自己已经占用了缓存区，对方无法使用缓存区，也就无法为你提供），即互斥的操作可能导致了同步的操作没办法再同步。即互斥后接同步中的后操作，而互斥操作后占用了同步中的先操作的临界区，导致同步的先操作无法完成</p>
<p>V操作不会导致阻塞，所以两个V操作顺序可以交换</p>
<hr>
<h1 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>与生产者消费者类似，多了一个轮流的操作</p>
<h2 id="分析与解决："><a href="#分析与解决：" class="headerlink" title="分析与解决："></a>分析与解决：</h2><p>多设置一个i，在每次生产后都对i加1取余，通过判断i的值来确定轮到谁进行操作</p>
<hr>
<h1 id="读者和写者问题"><a href="#读者和写者问题" class="headerlink" title="读者和写者问题"></a>读者和写者问题</h1><h2 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h2><p>读者可以一起进行读文件的操作，写者必须单独占用缓存区</p>
<h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>对缓存区上锁是很直接的想法，关键是如果仅仅是上锁，会导致读者不能同时进行读操作，所以需要增加一个count来进行计数，记录当前的读者数量，只有当读者数量为0时，才需要进行上锁的操作。</p>
<p>上述操作存在的问题时count的改变和上锁的动作无法保证连续执行，因此需要增加一个新的互斥量来保证对count的改变和上锁是连续的</p>
<h2 id="解答：-1"><a href="#解答：-1" class="headerlink" title="解答："></a>解答：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semaphore rw &#x3D; 1;</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line">semaphore mutex &#x3D; 1;</span><br><span class="line">semaphore w &#x3D; 1; &#x2F;&#x2F; 实现写优先,并不是绝对优先，而是相对于后来的读者有优先权，也可以称为读写公平</span><br><span class="line">writer()&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		P(w);</span><br><span class="line">		P(rw);</span><br><span class="line">		写文件；</span><br><span class="line">		V(rw);</span><br><span class="line">		V(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">reader()&#123;</span><br><span class="line">	P(w);</span><br><span class="line">	P(mutex);</span><br><span class="line">	if(count &#x3D;&#x3D; 0)&#123;</span><br><span class="line">		P(rw);</span><br><span class="line">	&#125;</span><br><span class="line">	count++;</span><br><span class="line">	V(mutex);</span><br><span class="line">	V(w);</span><br><span class="line">	读文件；</span><br><span class="line">	P(mutex);</span><br><span class="line">	count--;</span><br><span class="line">	if(count &#x3D;&#x3D; 0)&#123;</span><br><span class="line">		V(rw);</span><br><span class="line">	&#125;</span><br><span class="line">	V(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h2><p>增加了count计数来判断当前的读者数量，以实现读者的同时访问</p>
<p>此方法默认了读者的优先级更高，因为只要有读进程还在读，那么文件区就被上锁，写者无法访问，但是读者是可以访问的，新的读者进行访问，相当于延长了读者的时间，除非没有新的读者，且全部读者完成了读操作，此时写者才能进行写操作。可以增加一个信号量w来实现写优先，即在写之前对w进行占用，在对读者进行count++时也进行占用和释放。会发生当写进程被读者的rw阻塞时，新的读进程无法顺利完成count++的操作，即新的读进程无法加入读者行列，只能阻塞等待写进程完成后结束w的占用。实现了写的优先</p>
<hr>
<h1 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>每个进程需要多个不同的资源</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>每个进程都持有别人需要的资源，都无法完成操作但却同时占用了资源，会形成死锁</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络（1）基本概念</title>
    <url>/2020/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%881%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</p>
<p><strong><em>计算机网络是互联的、自治的计算机集合</em></strong></p>
<h2 id="二、功能"><a href="#二、功能" class="headerlink" title="二、功能"></a>二、功能</h2><ol>
<li>数据通信（连通性）</li>
<li>资源共享（硬件、软件和数据）</li>
<li>分布式处理（多台计算机各自承担同一工作的不同部分）</li>
<li>提高可靠性</li>
<li>负载均衡</li>
</ol>
<h2 id="三、组成"><a href="#三、组成" class="headerlink" title="三、组成"></a>三、组成</h2><ol>
<li>组成部分：硬件、软件、协议</li>
<li>工作方式：<ul>
<li>边缘部分：用户直接使用（C/S、P2P）</li>
<li>核心部分：为边缘部分服务</li>
</ul>
</li>
<li>功能组成：<ul>
<li>通信子网：实现数据通信</li>
<li>资源子网：实现资源共享/数据处理</li>
</ul>
</li>
</ol>
<h2 id="四、分类"><a href="#四、分类" class="headerlink" title="四、分类"></a>四、分类</h2><ol>
<li><p>按分布范围</p>
<ul>
<li>广域网WAN（交换技术）</li>
<li>城域网MAN</li>
<li>局域网LAN（广播技术）</li>
<li>个人区域网（PAN）</li>
</ul>
</li>
<li><p>按使用者分：公用网，专用网</p>
</li>
<li><p>按交换技术分：电路交换，报文交换，分组交换</p>
</li>
<li><p>按拓扑结构分：</p>
<p> <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl1oy3x8dtj30ie0aqjrq.jpg" alt="img"></p>
</li>
<li><p>按传输技术分：</p>
<ul>
<li>广播式网络：共享公共通信信道</li>
<li>点对点网络：使用分组储存转发和路由选择机制</li>
</ul>
</li>
</ol>
<h2 id="五、标准化工作"><a href="#五、标准化工作" class="headerlink" title="五、标准化工作"></a>五、标准化工作</h2><h3 id="标准的分类："><a href="#标准的分类：" class="headerlink" title="标准的分类："></a>标准的分类：</h3><ol>
<li>法定标准：由权威制定（OSI）</li>
<li>事实标准：由某些产品的主流技术（TCP/IP）</li>
</ol>
<h3 id="RFC（Request-For-Comments）"><a href="#RFC（Request-For-Comments）" class="headerlink" title="RFC（Request For Comments）"></a>RFC（Request For Comments）</h3><p>RFC是因特网的标准形式</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络（3）分层结构</title>
    <url>/2020/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%883%EF%BC%89%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="计算机网络的分层结构"><a href="#计算机网络的分层结构" class="headerlink" title="计算机网络的分层结构"></a>计算机网络的分层结构</h1><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><h3 id="为什么分层："><a href="#为什么分层：" class="headerlink" title="为什么分层："></a>为什么分层：</h3><ul>
<li>激活数据通路</li>
<li>告诉网络如何识别目的主机</li>
<li>查明目的主机状态</li>
<li>弄清楚目的主机的文件管理系统是否准备好</li>
<li>确保差错和意外可以解决</li>
</ul>
<h3 id="分层结构："><a href="#分层结构：" class="headerlink" title="分层结构："></a>分层结构：</h3><ul>
<li>协议：为进行网络中的对等实体数据交换而建立的规则、标准或约定称为网络协议<ul>
<li>语法：规定传送数据的格式</li>
<li>语义：规定所要完成的功能</li>
<li>同步：规定各种操作的顺序</li>
</ul>
</li>
<li>接口：上层使用下层服务的入口（仅在<strong>相邻层有接口</strong>，且所提供服务的具体细节对上一层完全屏蔽</li>
<li>服务：下层为上层提供的功能调用</li>
</ul>
<h3 id="分层的基本原则："><a href="#分层的基本原则：" class="headerlink" title="分层的基本原则："></a>分层的基本原则：</h3><ul>
<li>各层相互<strong>独立</strong>，每层只实现一种相对独立的功能</li>
<li>各层之间<strong>界面自然清晰</strong>，相互交流尽可能少</li>
<li>结构上可分割，<strong>每层都采用最合适的技术来实现</strong></li>
<li>保持上下层独立性，<strong>上层单向使用下层提供的服务</strong></li>
<li>分层结构能够促进标准化工作</li>
</ul>
<h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p>7层的法定标准</p>
<p>目的：支持异构网络系统的互联互通</p>
<p>结构：</p>
<ul>
<li>通信子网（数据通信）（中间系统）<ul>
<li>1.物理层：在物理媒体上实现比特流的传输<ul>
<li>定义接口特性</li>
<li>定义传输模式：单工、半双工、双工</li>
<li>定义传输速率</li>
<li>比特同步</li>
<li>比特编码</li>
</ul>
</li>
<li>2.数据链路层：把网络层的数据报组装成帧<ul>
<li>成帧：定义帧的开始和结束</li>
<li>差错控制：帧错+位错</li>
<li>流量控制</li>
<li>访问/接入控制：控制对信道的访问</li>
</ul>
</li>
<li>3.网络层<ul>
<li>路由选择，选择最佳路径</li>
<li>流量控制：协调速度</li>
<li>差错控制：检查错误</li>
<li>拥塞控制：宏观控制整个网络的拥塞状态</li>
</ul>
</li>
</ul>
</li>
<li>4.传输层：负责主机中两个进程的通信，功能：可靠传输、不可靠传输，差错控制，流量控制，复用分用</li>
<li>资源子网（数据处理）<ul>
<li>5.会话层：向表示层提供建立连接并有序地传输数据<ul>
<li>建立，管理，终止会话</li>
<li>插入校验点用来恢复通信</li>
</ul>
</li>
<li>6.表示层：处理两个通信系统中交换信息的表示方式<ul>
<li>数据格式变换</li>
<li>数据加密解密</li>
<li>数据压缩与恢复</li>
</ul>
</li>
<li>7.应用层：产生网络交互的应用</li>
</ul>
</li>
</ul>
<h2 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h2><ul>
<li>应用层：支持各种网络应用（FTP、SMTP、HTTP）</li>
<li>传输层：进程-进程的数据传输（TCP、UDP）</li>
<li>网络层：源主机到目的主机的数据分组路由与转发（IP、ICMP、OSPF）</li>
<li>数据链路层：把网络层传下来的数据报组装成帧（Ethernet、PPP）</li>
<li>比特传输</li>
</ul>
<h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><ul>
<li>应用层（HTTP/FTP/DNS）</li>
<li>传输层（TCP/UDP）</li>
<li>网际层（IP）</li>
<li>网络接口层（Ethernet/ATM/Frame Relay）</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络（2）性能指标</title>
    <url>/2020/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%882%EF%BC%89%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><h2 id="一、速率"><a href="#一、速率" class="headerlink" title="一、速率"></a>一、速率</h2><p>速率即数据率或称数据传输率或者比特率（比特：1/0 位）</p>
<p><strong><em>区分速率的单位和储存容量的单位</em></strong>     (1Byte = 8bit)<br>$$<br>\begin{aligned}<br>速率：&amp;1Tb/s &amp;=&amp; 10^3Gb &amp;=&amp; 10^6Mb/s &amp;=&amp; 10^9kb/s &amp;=&amp; 10^{12}b/s<br>\储存容量：&amp;1TB &amp;=&amp; 2^{10}GB &amp;=&amp; 2^{20}MB &amp;=&amp; 2^{30}KB &amp;=&amp; 2^{40}B \quad\quad = 2^{40}*8b<br>\end{aligned}<br>$$</p>
<h2 id="二、带宽"><a href="#二、带宽" class="headerlink" title="二、带宽"></a>二、带宽</h2><p>“带宽”原本指，某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）</p>
<p>计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的<strong>最高数据率</strong>，单位是“比特每秒”</p>
<p>指的是网络设备所支持的最高速度，因为信号在链路中的传播速度是一样的，都是光速，不同的只是设备单位时间可以发出的比特的个数</p>
<h2 id="三、吞吐量"><a href="#三、吞吐量" class="headerlink" title="三、吞吐量"></a>三、吞吐量</h2><p>表示在单位时间内通过某个网络（或信道、接口）的数据量。单位“比特每秒”</p>
<p>吞吐量和带宽的区别：吞吐量是带宽的实际情况，带宽是吞吐量的理论上限</p>
<h2 id="四、时延"><a href="#四、时延" class="headerlink" title="四、时延"></a>四、时延</h2><p>指数据从网络的一端传送到另一端所需的时间，单位是秒</p>
<ul>
<li>发送时延:$\frac{数据长度}{信道带宽（发送速率）}$</li>
<li> 传播时延：$\frac{信道长度}{电磁波在信道上的传播速率}$</li>
<li>排队时延：等待输出/输入链路可用</li>
<li>处理时延：检错，找出口</li>
</ul>
<h2 id="五、时延带宽积"><a href="#五、时延带宽积" class="headerlink" title="五、时延带宽积"></a>五、时延带宽积</h2><p>时延带宽积 = 传播时延 X 带宽        单位：bit</p>
<p>又称<strong>比特为单位的链路长度</strong>，即<strong>某段链路现在有多少比特</strong></p>
<h2 id="六、往返时延RTT"><a href="#六、往返时延RTT" class="headerlink" title="六、往返时延RTT"></a>六、往返时延RTT</h2><p>从发送方发送数据开始，到接收方收到接收方的确认（接收方收到数据后立即发送确认）总共经历的时延</p>
<p>RTT包括</p>
<ul>
<li>往返时延 = 传播时延 X 2</li>
<li>末端处理时间</li>
</ul>
<h2 id="七、利用率"><a href="#七、利用率" class="headerlink" title="七、利用率"></a>七、利用率</h2><ul>
<li>信道利用率：$\frac{有数据通过时间}{（有+无）数据通过时间}$</li>
<li>网络利用率：信道利用率</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络（4）物理层</title>
    <url>/2021/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%884%EF%BC%89%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>在连接各种计算机的传输媒体上传输数据比特流</p>
<p>主要任务：确定余传输媒体接口有关的一些特性</p>
<ul>
<li>机械特性：规定物理连接时所采用的规格、接口形状、引线等</li>
<li>电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等</li>
<li>功能特性：指明某一电平表示何种意义，接口部件的信号线用途</li>
<li>规程特性（过程特性）：定义物理线路的工作规程和时序的关系</li>
</ul>
<h2 id="数据通信例子："><a href="#数据通信例子：" class="headerlink" title="数据通信例子："></a>数据通信例子：</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm9qep6s8nj31hg0iuas9.jpg" alt="image-20210102224341083"></p>
<h2 id="相关术语："><a href="#相关术语：" class="headerlink" title="相关术语："></a>相关术语：</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm9qf7o2u8j31fi0ms1gv.jpg" alt="image-20210102224413342"></p>
<h3 id="三种通信方式："><a href="#三种通信方式：" class="headerlink" title="三种通信方式："></a>三种通信方式：</h3><table>
<thead>
<tr>
<th>名称</th>
<th>英文</th>
<th>定义</th>
<th>需要信道条数</th>
</tr>
</thead>
<tbody><tr>
<td>单工通信</td>
<td>Simplex</td>
<td>只能一个发一个收</td>
<td>一条</td>
</tr>
<tr>
<td>半双工通信</td>
<td>half-duplex</td>
<td>都可以发或者收，但是同一时间只能进行一个</td>
<td>两条</td>
</tr>
<tr>
<td>全双工通信</td>
<td>duplex</td>
<td>都可以同时收发数据</td>
<td>两条</td>
</tr>
</tbody></table>
<h3 id="两种数据传输方式"><a href="#两种数据传输方式" class="headerlink" title="两种数据传输方式"></a>两种数据传输方式</h3><table>
<thead>
<tr>
<th>传输方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>串行传输</td>
<td>速度慢，省钱，适合远距离</td>
</tr>
<tr>
<td>并行传输</td>
<td>速度快，耗钱，适合近距离</td>
</tr>
</tbody></table>
<h3 id="码原"><a href="#码原" class="headerlink" title="码原"></a>码原</h3><p>定义：码元是指用一个固定时长的信号波形（数字脉冲），代表离散数值的基本波形。当有多个离散状态时，成为M进制码元<br>一个码元可以携带多个比特的信息（即不为二进制时就可以不只一个比特<br>个人理解：码元就是在网线上传输的一个个信号段。码元的不同进制就是用来表示不同的数值的</p>
<h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>分为<strong>码元传输速率</strong>和<strong>信息传输速率</strong><br>信息传输速率就是b/s，就是我们平常说的<strong>网速</strong><br>码元可以理解为几个比特的<strong>集合</strong>，所以信息传输速率（网速）=码元传输速率x码元所带信息量（多少比特）<br>码元所带信息量（比特数）=log2（码元进制数）</p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>用来表示最高数据速率</p>
<h3 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h3><ul>
<li>码元传输速率</li>
<li>信号传输距离</li>
<li>噪声干扰</li>
<li>传输媒体质量</li>
</ul>
<p>码间串扰：接收端收到的信号波形失去了码元之间的清晰界限（频率太高）</p>
<h2 id="奈式准则（无噪声）"><a href="#奈式准则（无噪声）" class="headerlink" title="奈式准则（无噪声）"></a>奈式准则（无噪声）</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm9qy7o5vkj31gy0ncx6a.jpg" alt="image-20210102230229193"></p>
<h2 id="香农公式（有噪声）"><a href="#香农公式（有噪声）" class="headerlink" title="香农公式（有噪声）"></a>香农公式（有噪声）</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm9r4eqrxoj31ha0j07ok.jpg" alt="image-20210102230826383"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm9r4tscy9j31hk0n4kg1.jpg" alt="image-20210102230836321"></p>
<h2 id="基带信号和宽带-带通信号"><a href="#基带信号和宽带-带通信号" class="headerlink" title="基带信号和宽带/带通信号"></a>基带信号和宽带/带通信号</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm9rfcsy6kj31cg0c4wva.jpg" alt="image-20210102231856989"></p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>将数据转化为<strong>数字信号</strong><br>数字数据(digtal data)通过 数字发送器(digit emitter) 转化为 数字信号(digtal signal)</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm9rgcc4xpj30o204e3z7.jpg" alt="image-20210102231954526"></p>
<p>模拟数据(analog data)通过 PCM编码器(PCM coder) 转化为 数字信号 (digtal signal)</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmawpccr6ej30ni04eglv.jpg" alt="image-20210102232017666"></p>
<h3 id="常见的导向性传输介质"><a href="#常见的导向性传输介质" class="headerlink" title="常见的导向性传输介质"></a>常见的导向性传输介质</h3><ul>
<li><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3></li>
<li><h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3></li>
<li><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3></li>
</ul>
<h3 id="常见的非导向性传输介质"><a href="#常见的非导向性传输介质" class="headerlink" title="常见的非导向性传输介质"></a>常见的非导向性传输介质</h3><p>无线电波，微波，红外线</p>
<h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p>对信号进行再生和还原（数字信号）</p>
<p>两端是网段而不是子网</p>
<p>集线器是多口中继器，不能分割冲突域</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（8）内存</title>
    <url>/2021/01/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%888%EF%BC%89%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（7）死锁</title>
    <url>/2021/01/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%887%EF%BC%89%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>各个进程因为竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象</p>
<h2 id="四个必要条件："><a href="#四个必要条件：" class="headerlink" title="四个必要条件："></a>四个必要条件：</h2><ul>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</li>
<li>不剥夺条件：进程所获的的资源在未使用完之前，不能由其他进程强行夺走</li>
<li>请求和保持条件：进程已经保持了至少一个资源。但又申请其他资源，而且该资源被其他进程占用，自己进入阻塞，但又对自己已有的资源保持不放</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被下一个进程请求</li>
</ul>
<p>发生死锁是一定有循环等待，但是发生循环等待时未必发生死锁</p>
<h2 id="什么时候会发生死锁："><a href="#什么时候会发生死锁：" class="headerlink" title="什么时候会发生死锁："></a>什么时候会发生死锁：</h2><ul>
<li>对系统资源的竞争。各进程对不可剥夺的资源的竞争可能引起死锁，对可剥夺资源的竞争不会引起死锁</li>
<li>进程推进顺序非法。请求和释放资源的顺序不当</li>
<li>信号量的使用不当。如实现互斥的P操作在实现同步的P操作之前</li>
</ul>
<p>对不可剥夺的资源的不合理分配，可能导致死锁</p>
<h2 id="死锁的处理策略："><a href="#死锁的处理策略：" class="headerlink" title="死锁的处理策略："></a>死锁的处理策略：</h2><ul>
<li>预防死锁。破坏死锁产生的条件</li>
<li>避免死锁。用某种方法防止系统进入不安全状态（银行家算法）</li>
<li>死锁的检测和解除。允许死锁的发生，不过操作系统可以检测出死锁的发生，然后采取措施解除死锁</li>
</ul>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><ul>
<li>破坏互斥条件：把互斥使用的资源改造为允许共享使用<ul>
<li>使用spooling技术把独占设备更改为在逻辑上共享的设备</li>
<li>为了系统安全，有些地方不能破坏互斥性</li>
</ul>
</li>
<li>破坏不剥夺条件：<ul>
<li>进程请求不到新资源时，主动释放自己已占有的资源</li>
<li>进程请求的资源被其他进程占用时，由操作系统进行协助强行剥夺该资源</li>
<li>缺点：实现复杂，释放资源可能导致前一阶段工作失效（因此此方法适用于易保存和恢复的资源，如CPU），反复申请和释放资源增加开销，可能导致饥饿</li>
</ul>
</li>
<li>破坏请求和保持条件：<ul>
<li>采用静态分配法，在进程运行前一次申请所有的资源</li>
<li>缺点：需要短暂使用的资源的利用率低，也有可能导致饥饿</li>
</ul>
</li>
<li>破坏循环等待条件：<ul>
<li>采用顺序资源分配法：对资源进行编号，进程必须按照编号递增的顺序请求资源，即拥有大编号资源的进程无法请求小编号的资源，只能请求更大编号的资源，而更大资源编号的占有者一定能完成自己的进程释放资源</li>
<li>缺点：不方便增加新的设备、进程资源使用顺序和申请顺序不一致，导致资源利用率低、用户编程麻烦</li>
</ul>
</li>
</ul>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>安全序列：系统按照安全序列分配资源不会导致进程无法执行（发生死锁）</p>
<p>银行家算法步骤：</p>
<ul>
<li>检查此次申请是否超过了之前声明的最大需求数</li>
<li>检查此时系统剩余的可用资源是否还能满足这次请求</li>
<li>试探分配资源</li>
<li>使用安全性检查算法检查此次分配后是否还存在安全序列</li>
</ul>
<h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><p>检测死锁</p>
<ul>
<li>使用某种数据结构来保存资源的请求和分配信息</li>
<li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态</li>
</ul>
<p>解除死锁：</p>
<ul>
<li>资源剥夺法：挂起某些死锁进程，并抢占它的资源</li>
<li>撤销进程法：强制撤销部分甚至全部死锁进程</li>
<li>进程回退法：回退部分死锁进程，使整个系统回退到安全状态</li>
</ul>
<p>如何决定对哪个进程进行操作：</p>
<ul>
<li>进程优先级</li>
<li>已执行时间</li>
<li>还要多久完成</li>
<li>进程已使用多少资源</li>
<li>进程是交互式的还是批处理式的</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络（5）数据链路层</title>
    <url>/2021/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%885%EF%BC%89%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmawokq04uj31he0kin16.jpg" alt="image-20210103205141317"></p>
<h2 id="封装成帧与透明传输"><a href="#封装成帧与透明传输" class="headerlink" title="封装成帧与透明传输"></a>封装成帧与透明传输</h2><p><strong>封装成帧</strong>就是加将数据加头加尾，相当于将数据打包<br><strong>透明传输</strong>就是为了防止<strong>特殊的数据无法正常传输</strong>的的情况的发生，比如说在封装成帧的过程中出现数据中的某些标记符与开始/结束标记符恰巧重复等等情况</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmastn7rxtj31hi0p81gf.jpg" alt="image-20210103205250970"></p>
<h3 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h3><p>就是在帧的首部做<strong>计数</strong>，看看数据是否错误<br>缺点：如果在某一个帧内，标记位后面的某个字节的数据丢失，那么会影响后面的帧<br>比如3 1 1 和 4 2 2 2，如果前面的帧丢失变成 3 1，那么后面的4就会被补到前面变成 3 1 4导致错误</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmat0n9smpj30qi0bptc8.jpg" alt="在这里插入图片描述"></p>
<h3 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h3><p>就是加头加尾分别标记开始结束，和零比特填充法（见下）对比，<strong>开始和结束的对应的字符不一样</strong><br>但有可能出现数据内某段比特流数据正好<strong>与标记字段重复</strong>，从而导致误判断的情况<br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmat0y06noj30tc0fmn4f.jpg" alt="在这里插入图片描述"><br><strong>解决方法：添加转义字符</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200627122642435.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="零比特填充法"><a href="#零比特填充法" class="headerlink" title="零比特填充法"></a>零比特填充法</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmat1jhhvaj30te0eqqa6.jpg" alt="在这里插入图片描述"></p>
<h3 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmat1qwqk2j30tz0bjjua.jpg" alt="在这里插入图片描述"></p>
<h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><h3 id="差错是什么，从哪来的"><a href="#差错是什么，从哪来的" class="headerlink" title="差错是什么，从哪来的"></a>差错是什么，从哪来的</h3><p>数据链路层的差错检测的是<strong>比特</strong>的错误<br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmatfqqnx8j30tt0fjn5m.jpg" alt="在这里插入图片描述"></p>
<h3 id="为什么要在数据链路层进行差错控制？"><a href="#为什么要在数据链路层进行差错控制？" class="headerlink" title="为什么要在数据链路层进行差错控制？"></a>为什么要在数据链路层进行差错控制？</h3><p>因为错误可以尽早发现，不会让一个错误的数据包发送了很长时间到达最终目的地之后才被发现，从而导致网络资源的浪费</p>
<h2 id="检错编码（奇偶校验码，循环冗余码CRC）"><a href="#检错编码（奇偶校验码，循环冗余码CRC）" class="headerlink" title="检错编码（奇偶校验码，循环冗余码CRC）"></a>检错编码（奇偶校验码，循环冗余码CRC）</h2><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>缺点：只能检测出1，3，5，7…等等奇位数错误，检测成功率位50%<br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmatftfy9tj30hy04bwfw.jpg" alt="在这里插入图片描述"></p>
<h3 id="循环冗余码CRC"><a href="#循环冗余码CRC" class="headerlink" title="循环冗余码CRC"></a>循环冗余码CRC</h3><p>就是用传输数据除以生成多项式得到冗余码<br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmatfqbgrxj30ud047jtl.jpg" alt="在这里插入图片描述"><br>实际例子<br>注释：<br>1.阶数就是最高位是哪位，然后位数-1，如10011就是5-1=4,1011就是4-1=3<br>2.异或运算就是相同得0，不同得1，比如100和101做异或，结果就是001<br>3.出书和最后的余数添加到要发送的数据后面，称为<strong>帧检验序列FCS</strong><br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmatfr4gmoj30um0abq9t.jpg" alt="在这里插入图片描述"><br>接收方收到数据后进行检测<br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmatfrklpij30tr0d2tfv.jpg" alt="在这里插入图片描述"><br>需要注意的地方<br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmatfs48lcj30sr04jgq7.jpg" alt="在这里插入图片描述"></p>
<h2 id="纠错编码（海明码）"><a href="#纠错编码（海明码）" class="headerlink" title="纠错编码（海明码）"></a>纠错编码（海明码）</h2><p>分为四步</p>
<h3 id="第一步-确认校验码位数r"><a href="#第一步-确认校验码位数r" class="headerlink" title="第一步 确认校验码位数r"></a>第一步 确认校验码位数r</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmattscl84j30sj08ntcj.jpg" alt="在这里插入图片描述"></p>
<h3 id="第二步-确定校验码和数据的位置"><a href="#第二步-确定校验码和数据的位置" class="headerlink" title="第二步 确定校验码和数据的位置"></a>第二步 确定校验码和数据的位置</h3><p>注释：<br>1.为什么是10为数据位？因为4位校验码+6位信息位=10位<br>2.校验码放到2的几次方的位置，其他的地方按顺序放已知的信息位</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmattry01oj30tb0a9jve.jpg" alt="在这里插入图片描述"></p>
<h3 id="第三步-求出校验码的值"><a href="#第三步-求出校验码的值" class="headerlink" title="第三步 求出校验码的值"></a>第三步 求出校验码的值</h3><p>注释<br>1.先是通过二进制位确定有几位。本题中因为最大位10的二进制是1010，所以是4为，将其标注<br>2.然后从p1开始看，看p1的二进制位的数值和所有信息位的对应位置的数值是否相同，然后找出来这些位<br>这里有点难理解，这里以p1为例辅助理解，这里找出来的就是P1,D1,D2,D4,D5<br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmattsudebj30rk045myo.jpg" alt="在这里插入图片描述"><br>然后计算异或值，比如说这里D1=1,D2=0,D4=1,D5=0,就是p1要同时和<strong>0</strong>,<strong>1</strong>，<strong>0</strong>,<strong>1</strong>进行异或之后得到0，为了标识我加粗原始计算数据<br>举例：<strong>0</strong>和<strong>1</strong>异或得1,1和<strong>0</strong>异或得1,1和<strong>1</strong>异或得0，那么p1和0异或得0，p1就是0了<br>3.其他同理，按顺序计算出P2,P3,P4,然后填入表格<br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmattupm6zj30ss0g0gtv.jpg" alt="在这里插入图片描述"></p>
<h3 id="第四步-检测并纠错"><a href="#第四步-检测并纠错" class="headerlink" title="第四步 检测并纠错"></a>第四步 检测并纠错</h3><p>就是和上面一样，将所有校验位进行运算，得出的结果的值就是错误的位<br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmattu09uxj30u00g9thr.jpg" alt="在这里插入图片描述"></p>
<h2 id="数据链路层的流量控制和可靠传输"><a href="#数据链路层的流量控制和可靠传输" class="headerlink" title="数据链路层的流量控制和可靠传输"></a>数据链路层的流量控制和可靠传输</h2><h3 id="流量控制与可靠传输"><a href="#流量控制与可靠传输" class="headerlink" title="流量控制与可靠传输"></a>流量控制与可靠传输</h3><p>流量控制是为了让传输过程中的发送速度和接受速度匹配，减少传输出错与资源浪费<br>可靠传输是发送端发送什么，接收端就要受到什么</p>
<h3 id="停止等待协议（Stop-and-Wait）"><a href="#停止等待协议（Stop-and-Wait）" class="headerlink" title="停止等待协议（Stop-and-Wait）"></a>停止等待协议（Stop-and-Wait）</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmawnctsnrj30tc0d47c9.jpg" alt="在这里插入图片描述"><br>停止等待协议的<strong>无差错</strong>情况<br>注释：因为一次就一个，所以用0和1标记ack就行<br><img src="https://img-blog.csdnimg.cn/20200627150810912.png?xshadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>停止等待协议的<strong>有差错</strong>情况<br><img src="https://img-blog.csdnimg.cn/20200627151008798.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmawne2e45j30ns0f9tdn.jpg" alt="在这里插入图片描述"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmawnd353wj30ow0fmaey.jpg" alt="在这里插入图片描述"><br>停止等待协议的特点<br>1.简单<br>2.信道利用率低。大部分时间数据都在路上，发送方很长时间闲置，资源浪费<br><img src="https://img-blog.csdnimg.cn/20200627151529667.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmawnekrkvj30so0e7tfh.jpg" alt="在这里插入图片描述"></p>
<h3 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h3><p>因为停止等待协议太浪费时间了，所以尝试采用GBN，发送连续多个数据帧，以增大信道利用率<br>注释：<br>累计确认：就是收到一个确认帧，那么<strong>它和它之前的所有帧</strong>都默认已收到，反之，如果某个确认帧没收到，那么<strong>它和它之后的所有帧</strong>都默认丢失（即使收到了也丢掉），进行重传</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmawnvk2i5j30sg0ckwmt.jpg" alt="在这里插入图片描述"><br>下图是一个实例<br>注释：此图发送2帧时丢失，所以接收方几首收到后面的帧也是直接丢弃并且发送最晚收到的有效帧1的ACK，直至2帧的超时重传机制被触发进行重传并得到ACK之后，接收方才会接受2帧以及后面的帧</p>
<p><img src="https://img-blog.csdnimg.cn/20200627153111466.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发送窗口不能无限大，与使用的编号的比特数有关<br>很简单，就是1比特编号0和1,同理2比特编号0-3，如果用1比特编号，却要4个窗口长度，那么窗口内数据编号都编不过来，直接乱套了<br>GBN的优缺点也显而易见，优点是提高了信道利用率，缺点是因为重传机制的原因导致已经收到数据却需要强行丢弃而造成浪费</p>
<h3 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h3><p>为了解决GBN的缺点，我们打算尝试只重传错误的帧，这样的话就不用浪费资源吧已经收到的帧再重传一次了。<br>和GBN相比，两者都有窗口了，和GBN的区别其实就是做了一个数据缓存，已经收到的帧不用扔了，等待之前因意外丢失的帧收到的时候确认即可，但是只能缓存窗口尺寸内的包含的帧（PS，缓存咋可能无限大）<br>SR运行过程<br>注释：2帧丢失之后仍然在发送，但是2帧丢失之后只是缓存，并没有移动窗口，直至最后2帧收到后一次性确认2-5帧<br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmawoz5xnpj30v00hhjuv.jpg" alt="在这里插入图片描述"><br>同样的，因为编号的问题，发送窗口不能无限大<br>发送窗口最后和接受窗口<strong>大小相同</strong>，这样利用率比较高</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（1）策略模式</title>
    <url>/2021/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%881%EF%BC%89%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式（1）策略模式"><a href="#设计模式（1）策略模式" class="headerlink" title="设计模式（1）策略模式"></a>设计模式（1）策略模式</h1><h2 id="一、原则："><a href="#一、原则：" class="headerlink" title="一、原则："></a>一、原则：</h2><ol>
<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起<ol>
<li>把变化的部分取出并封装，以便于以后可以轻易地改动或扩充此部分，而不影响其它不需要变化的部分</li>
</ol>
</li>
<li>针对接口编程，而不是针对实现编程<ol>
<li>示例中实现的实例所用到的行为有相应的接口和实现类</li>
</ol>
</li>
<li>多用组合，少用继承<ol>
<li>在示例中fly和quack都使用了组合的方式，而不是继承</li>
<li>使用组合的方式拥有更大的弹性，不仅可将算法族封装成类更可以“在运行时动态地改变行为”</li>
</ol>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><a href="https://github.com/summerainnn/designPattern/tree/master/StrategyModel">示例</a></h3><h2 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h2><p>策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>应用</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（2）观察者模式</title>
    <url>/2021/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%882%EF%BC%89%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式（2）观察者模式"><a href="#设计模式（2）观察者模式" class="headerlink" title="设计模式（2）观察者模式"></a>设计模式（2）观察者模式</h1><h2 id="一、原则"><a href="#一、原则" class="headerlink" title="一、原则"></a>一、原则</h2><p>为了交互对象的松耦合设计而努力（松耦合可以将对象之间的相互依赖性降低）</p>
<p><a href="https://github.com/summerainnn/designPattern/tree/master/StrategyModel">示例</a></p>
<h2 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h2><p>定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会受到通知并自动更新</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>应用</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（3）装饰者模式</title>
    <url>/2021/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%883%EF%BC%89%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式（3）装饰者模式"><a href="#设计模式（3）装饰者模式" class="headerlink" title="设计模式（3）装饰者模式"></a>设计模式（3）装饰者模式</h1><h2 id="一、原则"><a href="#一、原则" class="headerlink" title="一、原则"></a>一、原则</h2><p>开放-关闭原则：类应当对扩展 开放，对修改关闭</p>
<p>不需要在每个地方都采用开放-关闭原则，把注意力集中在设计中最有可能改变的地方</p>
<p><a href="https://github.com/summerainnn/designPattern/tree/master/DecoratorPattern">示例</a></p>
<p>抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族。而不需要明确指定具体类</p>
<h2 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h2><p>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承者更有弹性的替代方案。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>应用</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（4）工厂模式</title>
    <url>/2021/01/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%884%EF%BC%89%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="一、原则"><a href="#一、原则" class="headerlink" title="一、原则"></a>一、原则</h2><p>要依赖抽象，不要依赖具体类</p>
<p><a href="https://github.com/summerainnn/designPattern/tree/master/FactoryPattern">示例</a></p>
<h2 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h2><p>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>应用</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>java常用函数总结</title>
    <url>/2021/01/25/java%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>无序的，不含重复元素的集合</p>
<p>创建一个HashSet：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;T&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashSet.add(<span class="string">&quot;hash&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>判断元素是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashSet.contains(<span class="string">&quot;hash&quot;</span>)</span><br><span class="line"><span class="comment">// 返回一个布尔值</span></span><br></pre></td></tr></table></figure>

<p>移除一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashSet.remove(<span class="string">&quot;hash&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>无序的散列表，储存内容为键值对</p>
<p>创建一个HashSet：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;T,T&gt; hashMap = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashMap.put(key,value);</span><br><span class="line"><span class="comment">// 如果key已存在则发生替换并返回旧value，否则返回null</span></span><br></pre></td></tr></table></figure>

<p>判断元素是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashMap.containsKey();</span><br><span class="line">hashMap.containsValue();</span><br><span class="line"><span class="comment">// 返回一个布尔值</span></span><br></pre></td></tr></table></figure>

<p>移除key对应的键值对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashMap.remove(key);</span><br></pre></td></tr></table></figure>

<p>获取key对应的value</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashMap.get(key);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><a href="https://www.runoob.com/java/java-hashmap-entryset.html">entrySet()</a></th>
<th>返回 hashMap 中所有映射项的集合集合视图。</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/java/java-hashmap-keyset.html">keySet</a>()</td>
<td>返回 hashMap 中所有 key 组成的集合视图。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/java/java-hashmap-values.html">values()</a></td>
<td>返回 hashMap 中存在的所有 value 值。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 03.数组中的重复元素</title>
    <url>/2020/11/08/%E5%89%91%E6%8C%87%20Offer%2003.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="剑指-Offer：03-数组中的重复元素"><a href="#剑指-Offer：03-数组中的重复元素" class="headerlink" title="剑指 Offer：03.数组中的重复元素"></a>剑指 Offer：03.数组中的重复元素</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<h3 id="LeetCoed"><a href="#LeetCoed" class="headerlink" title="LeetCoed"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">LeetCoed</a></h3><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="对原数组进行改变"><a href="#对原数组进行改变" class="headerlink" title="对原数组进行改变"></a>对原数组进行改变</h3><ul>
<li>实现复杂度为o（n），空间复杂度为o（1）</li>
</ul>
<ul>
<li>此处可对所有的重复数字进行查找</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                <span class="keyword">if</span>(nums[temp]==nums[i])&#123;</span><br><span class="line">                    answer[index] = nums[i];</span><br><span class="line">                    index++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[i] = nums[temp];</span><br><span class="line">                nums[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        answer[<span class="number">0</span>] = index-<span class="number">1</span>;<span class="comment">//用answer的第一个空间存储重复元素个数，可以实现多元素查找</span></span><br><span class="line">        <span class="keyword">return</span> answer[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="不改变原数组"><a href="#不改变原数组" class="headerlink" title="不改变原数组"></a>不改变原数组</h3><ul>
<li><p>用辅助数组进行，牺牲空间复杂度为o（n），时间复杂度仍为o（n）</p>
</li>
<li><p>用二分法可以将空间复杂度变为o（1），但时间复杂度为o（nlogn）<strong>（仅可查找一个重复元素，同时该方法要求数组元素的数量比所有数字的数量更大）</strong></p>
</li>
<li><p>使用HashSet同样可以实现时间复杂度为o（n）的解法，同时不用改变原数组</p>
</li>
</ul>
<p><em>HashSet是通过HashMap实现的一个不包含重复元素的集合，且没有key-value的对应关系</em></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; dic = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dic.add(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>重复</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 04.二维数组中的查找</title>
    <url>/2020/11/09/%E5%89%91%E6%8C%87%20Offer%2004.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="剑指-Offer：04-二维数组中的查找"><a href="#剑指-Offer：04-二维数组中的查找" class="headerlink" title="剑指 Offer：04.二维数组中的查找"></a>剑指 Offer：04.二维数组中的查找</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">LeetCode</a></h3><hr>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>根据该数组的特点，可从数组的右上角或者左下角开始，进行求解</li>
<li>专注于当前点，而不是下一个点，因为根据当前点即可判断出下一个点的位置，这也是初始点选择的好处所在</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = columns-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row&lt;rows&amp;&amp;column&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = matrix[row][column];</span><br><span class="line">            <span class="keyword">if</span>(num==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;target)&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                column--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
        <tag>线性查找</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 07.重建二叉树</title>
    <url>/2020/11/14/%E5%89%91%E6%8C%87%20Offer%2007.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="剑指-Offer：07-重建二叉树"><a href="#剑指-Offer：07-重建二叉树" class="headerlink" title="剑指 Offer：07.重建二叉树"></a>剑指 Offer：07.重建二叉树</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">&gt;中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>返回如下的二叉树：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">LeetCode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>首先理解什么是前序遍历和中序遍历：<ul>
<li>前序遍历：按照 根-&gt;左节点-&gt;右节点的顺序来遍历显示</li>
<li>中序遍历：按照 左节点-&gt;根-&gt;右节点的顺序来遍历显示</li>
</ul>
</li>
<li>前序遍历的首位一定是根结点，接着是这个根结点的左子树，然后是右子树</li>
<li>中序遍历的左部分为左子树，然后是根结点，接着是这个根结点的右子树</li>
<li>递归解决：<ul>
<li>用前序遍历找到根结点</li>
<li>在中序遍历中找到根结点，那么从根结点划分出两个子树，同时分出前序遍历的左右子树</li>
<li>重复该步骤，直到子树只有一个根结点</li>
</ul>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode father = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(inorder.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> father;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == preorder[<span class="number">0</span>])&#123;</span><br><span class="line"></span><br><span class="line">                father.left =  buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),</span><br><span class="line">                                         Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                father.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,</span><br><span class="line">                                                            preorder.length),</span><br><span class="line">                                         Arrays.copyOfRange(inorder,</span><br><span class="line">                                                            i+<span class="number">1</span>,inorder.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>可以新建一个类似的函数，改变传入的参数，直接使用原数组的空间，而不是子树遍历的拷贝</p>
]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 09.用两个栈实现队列</title>
    <url>/2020/11/14/%E5%89%91%E6%8C%87%20Offer%2009.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="剑指-Offer：09-用两个栈实现队列"><a href="#剑指-Offer：09-用两个栈实现队列" class="headerlink" title="剑指 Offer：09.用两个栈实现队列"></a>剑指 Offer：09.用两个栈实现队列</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>用两个栈实现一个队列。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">LeetCode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>队列是先进后出，而栈是先进先出</li>
<li>用两个栈，一个用来入栈，一个用来出栈</li>
<li>对于一系列存在一个栈内的数据出栈再入栈，那么它们在栈内储存的顺序就会反过来，即可实现队列</li>
</ul>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1;</span><br><span class="line">    Stack&lt;Integer&gt; s2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        s2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s2.empty()&amp;&amp;s1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 10- I. 斐波那契数列</title>
    <url>/2020/11/18/%E5%89%91%E6%8C%87%20Offer%2010-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="剑指-Offer：10-I-斐波那契数列"><a href="#剑指-Offer：10-I-斐波那契数列" class="headerlink" title="剑指 Offer：10- I. 斐波那契数列"></a>剑指 Offer：10- I. 斐波那契数列</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项。斐波那契数列的定义如下：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof">LeetCode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>斐波拉契数列是递归的典型应用，但是在使用递归时实际上做了很多无用功，对很多值进行了重复计数</li>
<li>利用动态规划的思想，将计算过的数值进行储存再利用即可</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i!=n)&#123;</span><br><span class="line">            sum = (s1 + s2) % <span class="number">1000000007</span>;</span><br><span class="line">            s1 = s2;</span><br><span class="line">            s2 = sum;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <url>/2020/11/18/%E5%89%91%E6%8C%87%20Offer%2010-%20II.%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="剑指-Offer：10-II-青蛙跳台阶问题"><a href="#剑指-Offer：10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer：10- II. 青蛙跳台阶问题"></a>剑指 Offer：10- II. 青蛙跳台阶问题</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">LeetCode</a></h3><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>简单分析可知，此题为斐波拉契数列的一种形式应用，与上一题类似</li>
<li>需要注意的是改变了斐波拉契数列的初始值</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numWays(int n) &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n&#x3D;&#x3D;2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int i &#x3D;2;</span><br><span class="line">        int s1 &#x3D; 1;</span><br><span class="line">        int s2 &#x3D; 2;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        while(i!&#x3D;n)&#123;</span><br><span class="line">            sum &#x3D; (s1 + s2) % 1000000007;</span><br><span class="line">            s1 &#x3D; s2;</span><br><span class="line">            s2 &#x3D; sum;</span><br><span class="line">            i &#x3D; i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 12.矩阵中的路径</title>
    <url>/2020/11/24/%E5%89%91%E6%8C%87%20Offer%2012.%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="剑指-Offer：12-矩阵中的路径"><a href="#剑指-Offer：12-矩阵中的路径" class="headerlink" title="剑指 Offer：12.矩阵中的路径"></a>剑指 Offer：12.矩阵中的路径</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</p>
<h3 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">LeetCode</a></h3><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul>
<li>这是一道比较典型的需要用到dfs的题目</li>
<li>需要对已经经过的点进行标记，完成后需要再恢复</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>专注于当前的点，而不是顾虑太多其它点，对每个点就行同样的处理，而不是特殊化</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, i, j,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word,<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;board.length-<span class="number">1</span>||y&gt;board[<span class="number">0</span>].length-<span class="number">1</span>||x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp = board[x][y];</span><br><span class="line">        <span class="keyword">if</span>(board[x][y] == word.charAt(k))&#123;</span><br><span class="line">            <span class="keyword">if</span>(k == word.length()-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">            board[x][y] =<span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfs(board,word,x+<span class="number">1</span>,y,k)||dfs(board,word,x-<span class="number">1</span>,y,k)</span><br><span class="line">                    ||dfs(board,word,x,y+<span class="number">1</span>,k)||dfs(board,word,x,y-<span class="number">1</span>,k))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>dfs</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 50. 第一个只出现一次的字符</title>
    <url>/2021/01/25/%E5%89%91%E6%8C%87%20Offer%2050.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%20/</url>
    <content><![CDATA[<h1 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a>剑指 Offer 50. 第一个只出现一次的字符</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">LeetCode</a></h2><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1.哈希表"></a>1.哈希表</h3><ul>
<li>使用HashMap（&lt;Character, Boolean&gt;）来记录每个字母出现的情况</li>
<li>若哈希表中不含有该key则放入，并设为true</li>
<li>若哈希表中已含有该key，则将其改为false</li>
<li>巧妙的利用containsKey，以及put发生的替换将代码简化</li>
<li>遍历字符串并返回哈希表中的value为true的字符（哈希表是无序的）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : sc)</span><br><span class="line">            map.put(c, !map.containsKey(c));<span class="comment">// 简化代码</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : sc)</span><br><span class="line">            <span class="keyword">if</span>(map.get(c)) <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-有序哈希表"><a href="#2-有序哈希表" class="headerlink" title="2.有序哈希表"></a>2.有序哈希表</h3><ul>
<li>使用有序哈希表来进行上述储存操作</li>
<li>遍历哈希表而不是字符串来找到第一个为true的key</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Boolean&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : sc)</span><br><span class="line">            map.put(c, !map.containsKey(c));</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character, Boolean&gt; d : map.entrySet())&#123;</span><br><span class="line">           <span class="keyword">if</span>(d.getValue()) <span class="keyword">return</span> d.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
    <url>/2021/01/26/%E5%89%91%E6%8C%87%20Offer%2052.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a>剑指 Offer 52. 两个链表的第一个公共节点</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>输入两个链表，找出它们的第一个公共节点。</p>
<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">LeetCode</a></h2><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>使用双指针遍历两个链表</li>
<li>当指针遍历到尾时指向另一个链表</li>
<li>当两个指针指同一节点时即可返回该节点</li>
<li>可以将每个链表的最后一个节点视为空节点，这样就可以将其统一为一定有公共节点，便于循环条件的判断</li>
</ul>
<p>注意：公共节点并不是指拥有相同值，而是相同的地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode temp1 = headA;</span><br><span class="line">        ListNode temp2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(temp1 != temp2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp1 = headB;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp1 = temp1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp2 = headA;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp2 = temp2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 53 - I. 在排序数组中查找数字 I</title>
    <url>/2021/01/27/%E5%89%91%E6%8C%87%20Offer%2053%20-%20I.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%20I/</url>
    <content><![CDATA[<h1 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>统计一个数字在排序数组中出现的次数。</p>
<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">LeetCode</a></h2><h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>一道典型的二分法的题目（有序的数组）</li>
<li>需要注意的是二分法的边界条件，否则易出错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&gt;=left)&#123;</span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[mid]) left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mid]) right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]!=target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((mid-<span class="number">1</span>)&gt;=<span class="number">0</span>&amp;&amp;nums[mid-<span class="number">1</span>]==target) &#123;</span><br><span class="line">            mid = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(mid!=nums.length&amp;&amp;nums[mid]== target)&#123;</span><br><span class="line">            sum = sum + <span class="number">1</span>;</span><br><span class="line">            mid = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 53 - II. 0～n-1中缺失的数字</title>
    <url>/2021/01/28/%E5%89%91%E6%8C%87%20Offer%2053%20-%20II.%200%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a>剑指 Offer 53 - II. 0～n-1中缺失的数字</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">LeetCode</a></h2><ul>
<li>与上一题类似，使用二分法即可</li>
<li>要多想多判断该以什么条件为节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&gt;=left)&#123;</span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==mid) left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = right - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>a</title>
    <url>/2021/02/09/a/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
